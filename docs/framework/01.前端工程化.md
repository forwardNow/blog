# 前端工程化

## 1. 介绍

* 概念

  * What： 什么是前端工程化？
  * Why ： 为什么需要前端工程化？ 
  * How ： 如何实现前端工程化？

* 应用

## 2. 什么是前端工程化

前端工程化 是 软件工程在前端应用，
用软件工程的方法 来解决 前端的开发流程中 **模块化**、**组件化**、**规范化**、**自动化** 的问题，
其主要目的为了 提高效率 和 降低成本。


模块化：对代码进行拆分，将一个大文件 拆成 若干职责单一的小文件

组件化：对 UI 进行拆分，将界面分解成一个个构件

自动化：就是把重复性的劳动交给构建工具去做，比如 批处理脚本、Ant、Grunt/Gulp、Webpack、Vite

规范化：标准、约束、约定、惯例，规范开发流程 


无论模块化还是组件化，都是在解决如何分而治之的问题

## 3. 为什么需要前端工程化

随着 web 业务越来越复杂化和多元化，前端项目越来越复杂，主要表现在：

* 代码量， 几百上千行 --> N 万行
* 人数， 一个人 --> N 个人

从而产生一些问题需要解决：

* 如何扩展 JavaScript、HTML、CSS 本身的语言能力

  * JavaScript 不完整： 没有 package/class
  * HTML、CSS 不是程序设计语言

* 如何进行高效的多人协作

  * 功能拆分与集成
  * 代码提交

* 如何解决功能复用和变更问题

* 如何保证项目的规范性

  * 一致性

* 如何实现重复的劳动简单化

  * 重复性的工作（脏活 累活）


要实现前端工程化，就要解决以上的几个问题。


## 4. 如何实现前端工程化

### 4.1. 如何扩展 JavaScript、HTML、CSS 本身的语言能力

JavaScript：

* TypeScript： Javascript 的超集，强类型语言
* ES6 + Babel： 最新的JS语法 + 转译器

HTML：

* 三大框架中的模板语法

  * Vue 和 Angular 的 template
  * React 的 JSX（符合XML规范的 JavaScript）

CSS：

* 预处理器 —— SASS 、LESS， 提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性

### 4.2. 如何进行高效的多人协作

模块化。

将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。只有这样，才有多人协作的可能。

JavaScript 模块化：

* 模块系统： ESM（官方）、CommonJS（Node.js 事实标准）
* 打包和加载： webpack，将所有模块打包成一个文件同步加载，也可以打成多个chunk（模块分组）异步加载

CSS 模块化：

* 类名冲突：BEM 命名约定
* 重复样式：CSS 预编译器，SCSS
* CSS 文件细分：工程化管理

参考：

* [jQuery](https://github.com/jquery/jquery) 模块化开发，核心文件 jquery.js

  ```javascript
  import jQuery from "./core.js";

  import "./selector.js";
  import "./traversing.js";
  import "./callbacks.js";
  import "./deferred.js";
  import "./deferred/exceptionHook.js";
  import "./core/ready.js";
  import "./data.js";
  import "./queue.js";
  import "./queue/delay.js";
  import "./attributes.js";
  import "./event.js";
  import "./event/trigger.js";
  import "./manipulation.js";
  import "./manipulation/_evalUrl.js";
  import "./wrap.js";
  import "./css.js";
  import "./css/hiddenVisibleSelectors.js";
  import "./css/showHide.js";
  import "./serialize.js";
  import "./ajax.js";
  import "./ajax/xhr.js";
  import "./ajax/script.js";
  import "./ajax/jsonp.js";
  import "./ajax/load.js";
  import "./core/parseXML.js";
  import "./core/parseHTML.js";
  import "./effects.js";
  import "./effects/animatedSelector.js";
  import "./offset.js";
  import "./dimensions.js";
  import "./deprecated.js";
  import "./exports/amd.js";
  import "./exports/global.js";

  export default jQuery;
  ```

* [bootstrap](https://github.com/twbs/bootstrap) 模块化开发，核心文件 bootstrap.scss

  ```scss
  /*!
   * Bootstrap v5.1.3 (https://getbootstrap.com/)
   * Copyright 2011-2022 The Bootstrap Authors
   * Copyright 2011-2022 Twitter, Inc.
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   */

  // scss-docs-start import-stack
  // Configuration
  @import "functions";
  @import "variables";
  @import "maps";
  @import "mixins";
  @import "utilities";

  // Layout & components
  @import "root";
  @import "reboot";
  @import "type";
  @import "images";
  @import "containers";
  @import "grid";
  @import "tables";
  @import "forms";
  @import "buttons";
  @import "transitions";
  @import "dropdown";
  @import "button-group";
  @import "nav";
  @import "navbar";
  @import "card";
  @import "accordion";
  @import "breadcrumb";
  @import "pagination";
  @import "badge";
  @import "alert";
  @import "progress";
  @import "list-group";
  @import "close";
  @import "toasts";
  @import "modal";
  @import "tooltip";
  @import "popover";
  @import "carousel";
  @import "spinners";
  @import "offcanvas";
  @import "placeholders";

  // Helpers
  @import "helpers";

  // Utilities
  @import "utilities/api";
  // scss-docs-end import-stack
  ```

### 4.3. 如何解决功能复用和性能问题

组件化。

组件：

* 从 UI 拆分下来的每个包含 **模板(HTML) + 样式(CSS) + 逻辑(JS)** 功能完备的结构单元

组件化更重要的是一种分治思想:

* 页面上所有的东西都是组件。
* 页面是个大型组件，可以拆成若干个中型组件，
* 然后中型组件还可以再拆，拆成若干个小型组件，
* 小型组件也可以再拆，直到拆成DOM元素为止。
* DOM元素可以看成是浏览器自身的组件，作为组件的基本单元。

组件化 与 模块化 的区别：

* 模块化只是在文件层面上，对代码或资源的拆分
* 而组件化是在设计层面上，对UI（用户界面）的拆分


### 4.4. 如何保证项目的规范性

模块化和组件化确定了开发模型，而这些东西的实现就需要规范去落实。

规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。

比如：

* 目录结构的制定
* 编码规范（ESLint、StyleLint）
* 前后端接口规范（swagger）
* 文档规范（ JS 注释规范 jsdoc）
* 组件管理
* Git 分支管理
* Commit 描述规范（commitLint)
* 定期 CodeReview
* 视觉图标规范

### 4.5. 如何实现重复的劳动简单化

自动化工具。

为什么要借助自动化工具呢？

在浏览器端，开发时态（devtime）和运行时态（runtime）的侧重点不一样。

开发时态，devtime：

  1. 模块划分越细越好
  2. 支持多种模块化标准
  3. 支持npm或其他包管理器下载的模块
  4. 能够解决其他工程化的问题（模块化、组件化、规范化）

运行时态，runtime：

  1. 文件越少越好
  2. 文件体积越小越好
  3. 代码内容越乱越好
  4. 所有浏览器都要兼容
  5. 能够解决其他运行时的问题，主要是执行效率问题

这种差异在小项目中表现的并不明显，可是一旦项目形成规模，就越来越明显，
如果不解决这些问题，前端项目形成规模只能是空谈。

既然开发时态和运行时态面临的局面有巨大的差异，
因此，我们需要有一个工具，
这个工具能够让开发者专心的在开发时态写代码，
然后利用这个工具将开发时态编写的代码转换为运行时态需要的东西。


这样的工具，叫做自动化构建工具，
前端工程化的很多脏活累活都应该交给自动化工具来完成。
现在比较流行的前端自动化构建工具有 gulp/grunt、webpack、vite.

## 5. 参考

* [谁能介绍下web前端工程化？ —— 知乎](https://www.zhihu.com/question/24558375)
* [什么是前端工程化？如何实现前端工程化？](https://www.cnblogs.com/zhengrongbaba/p/15097839.html)