# clean code -- 代码整洁之道

## 1. Meaningful Names (有意义的命名)

### 1.1. Use Intention-Revealing Names (使用透露意图的名称)

The name of a variable, function, or class, should answer all the big questions:

* why it exists
* what it does
* how it is used

bad：

```java
int d; // elapsed time in days
```

If a name requires a comment, then the name does not reveal its intent.

good:

```java
int elapsedTimeInDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgeInDays;
```

What is the purpose of this code?

```java
public List<int[]> getThem() {
  List<int[]> list1 = new ArrayList<int[]>();
  for (int[] x : theList)
    if (x[0] == 4) 
      list1.add(x);
  return list1;
}
```

The code implicitly requires that we know the answers to questions such as:

1. What kinds of things are in `theList`?
2. What is the significance of the zeroth subscript of an item in `theList`?
3. What is the significance of the value `4`?
4. How would I use the list being returned?

Say that we’re working in a mine sweeper game

```java
public List<int[]> getFlaggedCells() {
  List<int[]> flaggedCells = new ArrayList<int[]>();

  for (int[] cell : gameBoard)
    if (cell[STATUS_VALUE] == FLAGGED)
      flaggedCells.add(cell);

  return flaggedCells;
}
```

We can go further and write a simple class for cells instead of using an array of `int`s.

```java
 public List<Cell> getFlaggedCells() {
  List<Cell> flaggedCells = new ArrayList<Cell>();

  for (Cell cell : gameBoard)
    if (cell.isFlagged())
      flaggedCells.add(cell);

  return flaggedCells;
 }
```

### 1.2. Avoid Disinformation (避免误导)

Programmers must avoid leaving false clues that obscure the meaning of code.

不要使用专有名称

* 如 Unix 平台的专有名词： `hp`, `aix`, `sco` 等

不要使用特殊含义的名称

* 如 `List`，列表的意思
* `accountList` --> `accountGroup` / `bunchOfAccounts` / `accounts`

不要使用相似度很小的名称

* `XYZControllerForEfficientHandlingOfStrings`
* `XYZControllerForEfficientStorageOfStrings`
* 极端的例子
  ```java
  int a = l;
  if ( O == l )
    a = O1;
  else
    l = 01;
  ```

### 1.3. Make Meaningful Distinctions (有意义的区分)

you can’t use the same name to refer to two different things in the same scope,
you might be tempted to change one name in an arbitrary way:

* misspelling
* number series
* noise words

misspelling:

* `class`: `klass`

number series:

* `a1`, `a2`, .. `aN`

  ```java
  public static void copyChars(char a1[], char a2[]) {
    for (int i = 0; i < a1.length; i++) {
      a2[i] = a1[i]; 
    }
  }
  ```

* This function reads much better when `source` and `destination` are used for the argument names

noise words:

* `Product`: `ProductInfo` , `ProductData`. `Info` and `Data` are indistinct noise words like `a`, `an`, and `the`.
* The word `variable` should never appear in a variable name.
* The word `table` should never appear in a table name.
* How is `NameString` better than `Name`?  Would a `Name` ever be a floating point number?
* Imagine finding one class named `Customer` and another named `CustomerObject`.

### 1.4. Use Pronounceable Names (使用可以读出来的名字)

If you can’t pronounce it, you can’t discuss it without sounding like an idiot.

bad:

```java
class DtaRcrd102 {
  private Date genymdhms; 
  private Date modymdhms;
  private final String pszqint = "102";
  /* ... */
};
```

good: 

```java
class Customer {
  private Date generationTimestamp; 
  private Date modificationTimestamp;
  private final String recordId = "102";
  /* ... */
};
```

### 1.5. Use Searchable Names (使用可搜索的名称)

Single-letter names and numeric constants have a particular problem in that they are not easy to locate across a body of text. (单字符名称和数字常量很难被搜索到)

bad: 

```java
for (int j=0; j<34; j++) {
  s += (t[j]*4)/5;
}
```

good:

```java
int realDaysPerIdealDay = 4;
const int WORK_DAYS_PER_WEEK = 5;
int sum = 0;

for (int j=0; j < NUMBER_OF_TASKS; j++) {
  int realTaskDays = taskEstimate[j] * realDaysPerIdealDay;
  int realTaskWeeks = (realTaskDays / WORK_DAYS_PER_WEEK);
  sum += realTaskWeeks;
}
```

### 1.6. Avoid Encodings (避免使用编码)

Encoding type or scope information into names simply adds an extra burden of deciphering.
(将类型或作用域信息编进名称里面只会增加解码负担)

#### 1.6.1. Hungarian Notation (匈牙利命名法)

早期编译器不做类型检查，需要把类型编进名称来记住变量的类型，以 Hungarian Notation(HN)为代表。

现代编译器有强大的类型系统，HN 这种类型编码形式就没必要了。

```text
PhoneNumber phoneString; 
// name not changed when type changed!
```

#### 1.6.2. Member Prefixes (成员前缀)

没必要添加 `m_` 成员类型前缀，
应当把类和函数写得足够小，以消除对 `m_` 的需要，此外可使用可以通过高亮或颜色来标记成员的编辑器。

bad:

```java
public class Part { 
  private String m_dsc; // The textual description
  void setName(String name) {
    m_dsc = name;
  } 
}
```

good:

```java
public class Part { 
  String description;
  void setDescription(String description) { 
    this.description = description;
  } 
}
```

#### 1.6.3. Interfaces and Implementations (接口和实现)

有时也会遇到使用编码的情况，比如接口和实现：

bad:

```java
IShapeFactory   ShapeFactory
```

good:

```java
ShapeFactory   ShapeFactoryImp
```

### Avoid Mental Mapping (避免思维映射)

Professionals use their powers for good and write code that others can understand.

#### Class Names

Classes and objects should have noun or noun phrase names like `Customer`, `WikiPage`, `Account`, and `AddressParser`.

Avoid words like `Manager`, `Processor`, `Data`, or `Info` in the name of a class. 

A class name should not be a verb.

#### Method Names

Methods should have verb or verb phrase names like `postPayment`, `deletePage`, or `save`.

accessors（访问器）: `get` + `name`

mutators（修改器）: `set` + `name`

predicates（断言）: `is` + `name`

eg:

```java
String name = employee.getName();

customer.setName("mike");

if (paycheck.isPosted())...
```

#### Overloaded constructors

When constructors are overloaded, 
use static factory methods with names that describe the arguments. 

Consider enforcing their use by making the corresponding constructors private.

bad:

```java
Complex fulcrumPoint = new Complex(23.0);
```


good: 

```java
Complex fulcrumPoint = Complex.FromRealNumber(23.0);
```

#### Don't Be Cute （别抖机灵）

不要为了好玩而起一个别人很难理解的名字。

不要用俗语或俚语。

bad:

```java
HolyHandGrenade()
whack()
eatMyShorts()
```

good:

```java
DeleteItems()
kill()
abort()
```

#### Pick One Word per Concept (一个概念一个词)

对于一个抽象概念，坚持使用一个词

`fetch`, `retrieve`, `get` 所有的类中使用一个即可，不要存在多个

`controller`, `manager`, `driver` 使用一个即可

#### Don’t Pun (不要使用双关语)

比如， `add` 方法，有的表示将数值相加，有的表示将新元素添加到集合，
这种同一个方法名表示多个意思的就是双关

#### Use Solution Domain Names (使用解决方案相关的名称)

只有程序员才会读你的代码，尽可能使用程序员能懂的名称，如：

* computer science (CS) terms, e.g. `JobQueue`
* algorithm names
* pattern names , e.g. `AccountVisitor`
* math terms

#### Use Problem Domain Names (使用业务相关的名称)

如果不能使用程序员熟悉的术语，就采用业务相关的名称，至少可以去请教业务代表。

#### Add Meaningful Context (添加有意义的上下文)

尽量将名称放置于类、函数、名称空间，给名称提供上下文（语境）。

如果都没有，则添加前缀。

bad:  `firstName`, `lastName`, `state`

good: `addrFirstName`, `addrLastName`, `addrState`

bad: (Variables with unclear context.)

```java
private void printGuessStatistics(char candidate, int count) {
  String number;
  String verb;
  String pluralModifier;

  if (count == 0) {
    number = "no";
    verb = "are";
    pluralModifier = "s";
  } else if (count == 1) {
    number = "1";
    verb = "is";
    pluralModifier = "";
  } else {
    number = Integer.toString(count);
    verb = "are";
    pluralModifier = "s";
  
  }
  String guessMessage = String.format(
    "There %s %s %s%s", verb, number, candidate, pluralModifier
  );

  print(guessMessage);
}
```

good: (Variables have a context.)

```java
public class GuessStatisticsMessage {
  private String number;
  private String verb;
  private String pluralModifier;

  public String make(char candidate, int count) {
    createPluralDependentMessageParts(count);

    return String.format( "There %s %s %s%s", verb, number, candidate, pluralModifier );
  }

  private void createPluralDependentMessageParts(int count) {
    if (count == 0) {
      thereAreNoLetters();
    } else if (count == 1) {
      thereIsOneLetter();
    } else {
      thereAreManyLetters(count);
    }
  }

  private void thereAreManyLetters(int count) {
    number = Integer.toString(count);
    verb = "are";
    pluralModifier = "s";
  }
  private void thereIsOneLetter() {
    number = "1";
    verb = "is";
    pluralModifier = "";
  }
  private void thereAreNoLetters() {
    number = "no";
    verb = "are";
    pluralModifier = "s";
  }
}
```

#### Don’t Add Gratuitous Context (不要随意添加上下文前缀)