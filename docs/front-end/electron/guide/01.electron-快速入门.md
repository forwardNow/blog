<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2025-08-02 17:10:48
@modify date 2025-08-16 16:19:09
@desc [description]
#endregion-->

# electron - 快速入门

## 1. 什么是 Electron？

Electron 是⼀个跨平台桌⾯应⽤开发框架，

开发者可以使⽤：HTML、CSS、JavaScript 等 Web 技术来构建桌⾯应⽤程序，

它的本质是结合了 Chromium 和 Node.js，现在⼴泛⽤于桌⾯应⽤程序开发

官网: https://www.electronjs.org/

## 2. Electron 的优势

1. 可跨平台：同⼀套代码可以构建出能在：Windows、macOS、Linux 上运⾏的应⽤程序。
2. 上⼿容易：使⽤ Web 技术就可以轻松完成开发桌⾯应⽤程序。
3. 底层权限：允许应⽤程序访问⽂件系统、操作系统等底层功能，从⽽实现复杂的系统交互。
4. 社区⽀持：拥有⼀个庞⼤且活跃的社区，开发者可以轻松找到⽂档、教程和开源库。

## 3. Electron 技术架构

### 3.1. 技术架构

![image-20250802170809861](./images/image-20250802170809861.png)

### 3.2. 进程模型

![image-20250802170856059](./images/image-20250802170856059.png)

## 4. 搭建⼀个⼯程

说明:

* entry point should be main.js (you will be creating that file soon).
* author, license, and description can be any value, but will be necessary for packaging later on.

依赖:

```shell
npm i -D electron
```

package.json:

```json
{
  "name": "electron-proj",
  "version": "1.0.0",
  "main": "main.js",
  "scripts": {
    "start": "electron ."
  },
  "author": "wuqinfei",
  "license": "ISC",
  "description": "this is electron app",
  "devDependencies": {
    "electron": "^37.3.0"
  }
}
```

main.js:

```js
const { app, BrowserWindow } = require("electron");

app.on('ready', () => {
  let browserWindow = new BrowserWindow({
    width: 800,
    height: 600,

    // 隐藏菜单栏
    // https://www.electronjs.org/docs/latest/api/browser-window#winautohidemenubar-linux-windows
    autoHideMenuBar: true,

    // x: 0, // 初始位置
    // y: 0, // 初始位置
    alwaysOnTop: true,  // 置顶
  });
})
```

运行:

```shell
npm start
```

## 5. 加载本地页面

目录:

```text
electron-proj/
  index.js
  pages/
    index.html
    index.css
```

index.js:

```js
browserWindow.loadFile('./pages/index.html')
```

index.html:

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:;">
  <title>Document</title>
</head>
<body>
  <h1>Hello</h1>
</body>
</html>
```

## 6. 完善窗口行为

```js
const { app, BrowserWindow } = require("electron");

function createWindow() {
  let browserWindow = new BrowserWindow({
    width: 800,
    height: 600,

    // 隐藏菜单栏
    // https://www.electronjs.org/docs/latest/api/browser-window#winautohidemenubar-linux-windows
    autoHideMenuBar: true,

    // x: 0, // 初始位置
    // y: 0, // 初始位置
    alwaysOnTop: true,  // 置顶
  });

  browserWindow.loadFile('./pages/index.html')
}

// 当app准备好后，执⾏createWindow创建窗⼝
app.on('ready',()=>{
  createWindow()


  // 2. mac 应⽤即使在没有打开任何窗⼝的情况下也继续运⾏，并且在没有窗⼝可⽤的情况下激活应⽤时会打开新的窗⼝。

  // 当应⽤被激活时
  app.on('activate', () => {
    //如果当前应⽤没有窗⼝，则创建⼀个新的窗⼝
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  })
})


// 1. Windows 和 Linux 平台窗⼝特点是：关闭所有窗⼝时退出应⽤。

// 当所有窗⼝都关闭时
app.on('window-all-closed', () => {
  // 如果所处平台不是mac(darwin)，则退出应⽤。
  if (process.platform !== 'darwin') app.quit()
})
```

## 7. 配置⾃动重启

安装 nodemon:

```shell
npm i nodemon -D
```

修改 package.json 命令:

```json
"scripts": {
  "start": "nodemon --exec electron ."
},
```

配置 nodemon.json 规则:

```json
{
  "ignore": [
    "node_modules",
    "dist"
  ],
  "restartable": "r",
  "watch": ["*.*"],
  "ext": "html,js,css"
}
```

## 8. 主进程与渲染进程

### 8.1. 主进程

>入口点 main.js

每个 Electron 应⽤都有⼀个单⼀的主进程，作为应⽤程序的⼊⼝点。 

主进程在 Node.js 环境中运⾏，它具有 require 模块和使⽤所有 Node.js API 的能⼒，主进程的核⼼就是：使用 BrowserWindow 创建和管理窗口

### 8.2. 渲染进程

>页面通过 `<script>` 引入的 JS

每个 BrowserWindow 实例都对应⼀个单独的渲染器进程，运⾏在渲染器进程中的代码，必须遵守⽹⻚标准，这也就意味着：渲染进程无法访问 node API

## 9. preload

预加载（Preload）脚本是运⾏在渲染进程中的， 但它是在⽹⻚内容加载之前执⾏的，这意味着它具有⽐普通渲染器代码更⾼的权限，可以访问 Node.js 的 API，同时⼜可以与⽹⻚内容进⾏安全的交互。

简单说：它是 Node.js 和 Web API 的桥梁，Preload 脚本可以安全地将部分 Node.js 功能暴露给⽹⻚，从⽽减少安全⻛险。

在主进程里创建窗口时加载 preload.js:

```js
let browserWindow = new BrowserWindow({
  // ...

  webPreferences: {
    preload: path.resolve(__dirname, './preload.js')
  },
});
```

在 preload.js 里将数据挂载到 window 对象:

```js
const { contextBridge} = require('electron')

// 暴露数据给渲染进程
contextBridge.exposeInMainWorld('myAPI',{
  // 传递数据
  nodeVersion: process.version,

  // 供渲染进程调用
  sayHello(name) {
    console.log(`${name}, hello`);
  },
})
```

在 render.js 里访问:

```js
console.log(window.myAPI);
/* =>
{
    "name": "张三",
    "nodeVersion": "v22.18.0"
}
*/ 

document.getElementById('btn1').onclick = () => {
  window.myAPI.sayHello("张三")
};
```

## 10. 进程通信（IPC）

IPC  全称为： InterProcess Communication ，即：进程通信。

IPC 是 Electron 中最为核⼼的内容，它是从 UI 调⽤原⽣ API 的唯⼀⽅法！

Electron 中，主要使⽤ ipcMain 和 ipcRenderer 来定义“通道”，进⾏进程通信。

### 10.1. 渲染进程 到 主进程 （单向）

render.js:

```js
const { ipcRenderer} = require('electron')

ipcRenderer.send("channel-1", data)
```

main.js:

```js
const { ipcMain } = require("electron");

ipcMain.on('channel-1', (event, data) => {
  // 需要将 CMD 设置成 UTF-8 编码，执行如下命令
  // chcp 65001
  console.log('channel-1', data);
})
```
