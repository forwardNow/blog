# TypeScript 类型系统

## 1. 基本概念

基本注解：

* 类型注解使用 TypeAnnotation 语法
* 类型声明空间中内容都可以用作注解
* 示例：

    ```typescript
    const num: number = 10;

    function identity(num: number): number {
      return num;
    }
    ```

基本类型注解：

* `string` / `number` / `boolean`
* 示例：

    ```typescript
    let num: number;
    let str: string;
    let bool: boolean;
    ```

数组注解：

* `类型[]`
* 示例：

    ```typescript
    let boolArr: boolean[];
    ```

接口注解：

* 合并多个类型注解
* 示例：

    ```typescript
    interface Name {
      first: string;
      seconde: string;
    }

    let name: Name;
    ```

内联注解：

* 不用给类型起名字，只用一次
* 示例：

    ```typescript
    let name: {
      first: string;
      seconde: string;
    };
    ```

特殊类型：

* `any`: 关闭类型检查，可赋值给任意类型的变量
* `null` / `undefined`: 可赋值给任意类型的变量
* `void`: 表示函数没有返回值

泛型：

* 示例：

    ```typescript
    function reserve<T>(items: T[]): T[] {
      const toreturn = [];

      for (let i = items.length - 1; i >= 0; i--) {
        toreturn.push(items[i]);
      }

      return toreturn;
    }

    const arr = [1, 2, 3];

    const reserved = reserve(arr);
    ```

联合类型注解：

* 多个类型中挑一个
* 示例：

    ```typescript
    function formatCommandLine(command: string[] | string) {
      // ...
    }
    ```

交叉类型：

* 两个类型的并集
* 示例：

    ```typescript
    // first 继承 second 的属性，同名不覆盖
    function extend<T, U>(first: T, second: U): T & U {
      const result = {} as (T & U);

      for (let key in first) {
        (result as T)[key] = first[key];
      }

      for (let key in second) {
        if (!(result as Object).hasOwnProperty(key)) {
          (result as U)[key] = second[key];
        }
      }

      return result;
    }

    const x = extend({ a: 1, b: 2 }, { b: '2', c: '3' });

    console.log(x); 
    /*
      {
        "a": 1,
        "b": 2,
        "c": "3"
      } 
    */ 
    ```

元组：

* `[类型1, 类型2, ...]`
* 特殊的数组类型，相当于指定参数列表

类型别名：

* 给长类型起别名
* 示例：

    ```typescript
    type Text = string | { text: string };

    type coordinates = [ number, number ];

    type Callback = (date: string) => void;
    ```

## 2. JS 迁移到 TS

步骤：

1. 添加 tsconfig.json 文件
2. 将 `.js` 文件改为 `.ts` 文件
3. 在旧代码中使用类型注解，修复已识别的错误
4. 为第三方 JS 库定义环境声明

减少错误：

* 通过 类型断言 减少错误
* 示例：

    ```typescript
    let foo = 123;
    let bar = 'a';

    bar = foo as any;
    ```

第三方 JS 代码：

* 在 `vender.d.ts` 为其定义类型
* 创建针对特定库的声明文件： `jquery.d.ts`:

    ```typescript
    declare type JQuery = any;

    // 定义全局变量
    declare var $: JQuery;
    ```

第三方 NPM 模块：

* 声明：

    ```typescript
    // 定义全局模块
    declare module 'jquery';
    ```
* 使用：

    ```typescript
    import * as $ from 'jquery';
    ```

非 JS 资源：

* 声明：

    ```typescript
    declare module '*.css';
    declare module '*.html';
    ```

* 使用：

    ```typescript
    import * as style from './style/style.css';

    import * as app from './template/app.html';
    ```

## 3. @types

`compilerOptions.typeRoots`:

* 默认情况下，所有 `node_modules/@types` 下的包的类型声明都会加入编译


## 4. 环境声明

为第三方库编写声明文件，通过 `declare` 关键字声明变量、函数、类等

## 5. 接口

略

## 6. 枚举

略

## 7. lib.d.ts

安装 typescript 后，会有 lib.d.ts 文件：

* 位置：`node_modules\typescript\lib\lib.d.ts`
* 内容：

    ```typescript
    /// <reference lib="es5" />
    /// <reference lib="dom" />
    /// <reference lib="webworker.importscripts" />
    /// <reference lib="scripthost" />
    ```

## 8. 函数

重载：

```typescript
// 重载：
function sum(x: number): number;
function sum(x: number, y: number): number;
function sum(x: number, y: number, z: number): number;

// 实现
function sum(x: number, y?: number, z?: number) {
  if (y == null) {
    y = 0;
  }
  if (z == null) {
    z = 0;
  }
  return x + y + z;
};

console.log(sum(1));
console.log(sum(1, 2));
console.log(sum(1, 2, 3));
```

声明函数：

```typescript
type ISum = {
  (x: number): number;
  (x: number, y: number): number;
  (x: number, y: number, z: number): number;
}

type ISum2 = (x: number) => number;

//--

let sum: ISum;

sum = function sum(x: number, y?: number, z?: number) {
  if (y == null) {
    y = 0;
  }
  if (z == null) {
    z = 0;
  }
  return x + y + z;
};

console.log(sum(1));
console.log(sum(1, 2));
console.log(sum(1, 2, 3));
```

## 9. 可调用

接口：

```typescript
interface ISum {
  (x: number): number;
}

let sum1: ISum = function (x) {
  return x;
};
```

箭头函数：

```typescript
type ISum = (x: number) => number;

let sum1: ISum = function (x) {
  return x;
};
```

可实例化：

```typescript
class Person {
  constructor(public name: string) {
  }

  sayHello() {
    console.log(this.name, 'hello');
  }
}

interface IPerson {
  new (name: string): Person;
}

function sayHello(P: IPerson) {
  new P('张三').sayHello();
}

sayHello(Person);
```

## 10. 类型断言

当 S 是 T 的子集，或 T 是 S 的子集时：

* S 能被断言为 T

当 S: T | U 时：

* S 能被断言为 T


双重断言：

```typescript
function handler(event: Event) {
  // const element = event as HTMLElement; // 错误
  const element = (event as any) as HTMLElement;
}
```

## 11. freshness

更严格的 对象字面量类型 检查：

```typescript
function logName(obj: { name?: string }) {
  console.log(obj.name);
}

const person = { name: '张三', age: 18 };
logName(person);

logName({}); // ok
logName({ name: '张三', age: 18 }); // 错误：对象字面量只能指定已知属性 
```

## 12. 类型保护

typeof:

```typescript
function doSome(s: number | string) {
  if (typeof s === 'number') { 
    // TS 推导出这个块 s 为 number 类型
    s.toFixed(2);
  } else { 
    // TS 推导出这个块 s 为 string 类型
    s.substring(1, 3);
  }
}
```

instanceof:

```typescript
function doStuff(arg: Person | Point) {
  if (arg instanceof Person) {
    // TS 推导出这个块 arg 是 Person 类型
    arg.name;
    return;
  }

  // TS 推导出这个块 arg 是 Point 类型

  arg.x;
}
```

in:

```typescript
interface IPerson {
  name: string;
  age: number;
}

interface IPoint {
  x: number;
}

function doStuff(arg: IPerson | IPoint) {
  if ('name' in arg) {
    // TS 推导出这个块 arg 是 IPerson 类型
    arg.age;
  } else {
    // TS 推导出这个块 arg 是 IPoint 类型
    arg.x;
  }
}
```

字面量类型：

```typescript
type IState = 'yes' | 'no';

function doStuff(state: IState) {
  if (state == 'yes') {

  } else if (state == 'no') {
    
  }
}
```

null 和 undefined：

```typescript
function doStuff(state?: string | null) {
  if (state == null) {
    // TS 推导出这个块 state 是 null 或 undefined 类型
    return;
  }

  // TS 推导出这个块 state 是 string 类型

  state.substring(1, 2);
}
```

自定义类型保护：

```typescript
interface IPerson {
  name: string;
  age: number;
}

interface IPoint {
  x: number;
}

function isPerson(arg: IPerson | IPoint): arg is IPerson {
  return (arg as IPerson).name !== undefined;
}

function doStuff(arg: IPerson | IPoint) {
  if (isPerson(arg)) {
    // TS 推导出这个块 arg 是 IPerson 类型
    arg.age;
  } else {
    // TS 推导出这个块 arg 是 IPoint 类型
    arg.x;
  }
}
```

回调函数：

```typescript
declare var person: { address?: { road: string } };

function doSome(callback: Function) {
  callback();
}

console.log(person.address.road); // 错误: 'person.address' is possibly 'undefined'

if (person.address) {
  console.log(person.address.road);

  var address = person.address;

  doSome(() => {
    console.log(person.address.road); // 错误: 'person.address' is possibly 'undefined'.

    console.log(address.road); // ok
  });
}
```