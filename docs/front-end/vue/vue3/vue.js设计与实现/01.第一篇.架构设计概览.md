# 第一篇.架构设计概览

## 1. 第 1 章 权衡的艺术

### 1.1. 命令式和声明式

视图层框架按范式分为：

* 命令式：关注过程，与自然语音一一对应
* 声明式：关注结果，由框架来实现过程

### 1.2. 性能和可维护性

框架封装了命令式代码，以实现面向用户的命令式

声明式代码的性能不优于命令式代码的性能

### 1.3. 虚拟 DOM 的性能到底如何

声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗

虚拟 DOM 就是为了最小化找出差异才出现的

新建页面：

| 运算    | innerHTML(模板)     | 虚拟DOM               |
| ------- | :------------------ | --------------------- |
| JS运算  | 渲染 HTML 字符串    | 创建JS对象（虚拟DOM） |
| DOM运算 | 新建所有新 DOM 元素 | 新建所有新 DOM 元素   |

更新页面：

| 运算    | innerHTML(模板)                          | 虚拟DOM                    |
| ------- | :--------------------------------------- | -------------------------- |
| JS运算  | 渲染 HTML 字符串                         | 创建新的虚拟DOM对象 + diff |
| DOM运算 | 销毁所有旧 DOM 元素，新建所有新 DOM 元素 | 必要的 DOM 更新            |

### 1.4. 运行时和编译时

纯 运行时 框架：

* 源码：

    ```js
    // obj -> DOM 
    function render(obj, root) {
      const el = document.createElement(obj.tag);

      if (typeof obj.children === 'string') {
        const text = document.createTextNode(obj.children);
        el.appendChild(text);
      } else if (obj.children) {
        obj.children.forEach((child) => render(child, el));
      }

      root.appendChild(el);
    }
    ```

* 使用：

    ```js
    const obj = {
      tag: 'div',
      children: [
        { tag: 'span', children: 'hello world' },
      ]
    }
    
    render(obj, document.body);
    ```

编译时 + 运行时 框架：

* 源码

    ```ts
    // htmlStr -> obj
    function compile(htmlStr): obj;

    // obj -> DOM 
    function render(obj, root);
    ```

* 使用

    ```js
    const htmlStr = `
      <div>
        <span>hello world</span>
      </div>
    `
    const obj = compile(htmlStr);
    
    render(obj, document.body);
    ```

纯 编译时 框架：

* 源码

    ```ts
    // htmlStr -> DOM
    function compile(htmlStr): DOM;
    ```

* 使用

    ```js
    const htmlStr = `
      <div>
        <span>hello world</span>
      </div>
    `
    const dom = compile(htmlStr);
    
    document.body.appendChild(dom);
    ```

## 2. 第 2 章 框架设计的核心要素

### 2.1. 提升用户的开发体验

友好的警告、错误提示信息，让我们能够清晰快速地定位问题。

源码中 `initCustomFormatter` 函数用于在开发环境设置浏览器自定义输出的格式

开启浏览器自定义输出格式：

* Settings -> Preferences 
* Console -> Enable custom formatters

### 2.2. 控制框架代码的体积

vue.js 使用 rollup.js 进行构建，会输出两种版本：

* 开发版
* 生产版

打印语句：

```js
// __DEV__ 构建工具预定义常量
if (__DEV__ && !res) {
  warn(
    `Failed to mount app: mount target selector "${container}" returned null`
  );
}
```

开发环境时：

```js
/*
  这段永远不会执行的代码为 dead code，编译时会被移除，这就减少了代码的体积
*/
if (false && !res) {
  warn(
    `Failed to mount app: mount target selector "${container}" returned null`
  );
}
```

总结：

* 构建工具设置预定义常量 `__DEV__`，在生产环境不包含打印语句，从而使得框架自身的代码量不随着警告信息的增加而增加。

### 2.3. 框架要做到良好的 tree-shaking

说明：

* tree-shaking 因 rollup.js 而普及
* 作用：消除那些永远不会执行的代码，即排除 dead code

条件：

* 针对 ESModule（依赖 ESM 的静态结构）
* 移除没有副作用的 dead code 

标记为没有副作用的代码：

```js
// utils.js
export function add(num1, num2) {
  return num1 + num2;
}

// main.js
import { add } from './utils';

add(1, 2);

/*#__PURE__*/ console.log( add(1, 2) );
```

tree-shaking 后，上面三行代码都会被移除：

```shell
npx rollup main.js -f esm -o bundle.js
```

### 2.4. 框架应该输出怎样的构建产物

带 `-browser` 的都是给浏览器用的，如 `vue.esm-browser.js`

带 `-bundle` 的是给构建工具用的：

```js
if (__DEV__) {
  // ...
}

// => __DEV__ 会被替换
if (process.env.NODE_ENV !== 'production') {
  // ...
}
```

webpack、rollup.js 寻找资源时，会优先使用 package.json 中的 `module` 属性：

```json
{
  "main": "index.js",
  "module": "dist/vue.runtime.esm-bundle.js"
}
```

### 2.5. 特性开关

通过预定义常量来控制是否包含某特新的代码

源码：

```js
// support for 2.x options
if (__FEATURE_OPTIONS_API__) {
  // ...
}
```

带 `-bundle` 的代码：

```js
if (__VUE_OPTIONS_API__) {
  // ...
}
```

在 webpack 中设置值：

```js
new webpack.DefinePlugin({
  __VUE_OPTIONS_API__: JSON.stringify(true)
})
```

### 2.6. 错误处理

统一的错误处理接口：

* utils.js

    ```js
    let errorHandler = (e) => console.log(e);

    export default {
      fn1(callback) {
        callWithErrorHandling(callback);
      },

      fn2(callback) {
        callWithErrorHandling(callback);
      },

      registerErrorHandler(fn) {
        errorHandler = fn;
      }
    }

    function callWithErrorHandling(fn) {
      try {
        fn && fn();
      } catch(e) {
        console.log(e);
      }
    }
    ```

* 使用：

    ```js
    import utils from './utils';

    utils.registerErrorHandler((e) => {
      console.log(e.message);
    })

    utils.fn1(() => {/* ... */});
    utils.fn2(() => {/* ... */});
    ```

在 vue 中注册统一的错误处理函数：

```js
app.config.errorHandler = () => {
  // ...
}
```

### 2.7. 良好的 TS 类型支持

用 TS 编写框架，与对 TS 类型支持友好 是两码事

### 2.8. 总结

提供友好的警告信息很重要，有助于开发者快速定位问题

但警告信息越详细，框架体积越大

利用 tree-shaking 和 预定义常量 `__DEV__` 排除掉提升开发体验的代码以减小包的体积

tree-shaking 是一种排除机制，基于 ESM，可利用 `/*#__PURE__*/` 注释来辅助构建工具

## 3. 第 3 章 Vue.js 3 的设计思路

### 3.1. 声明式地描述 UI

用模版描述 UI：

```html
<h1 @click="handler">
  <span></span>
</h1>
```

用 JS 对象（虚拟DOM）描述 UI：

```js
const title = {
  tag: 'h1',
  props: {
    onClick: handler,
  },
  children: [
    { tag: 'span' }
  ]
};
```

通过渲染函数描述：

```js
import { h } from 'vue';

export default {
  render() {
    return h('h1', { onClick: handler })
  }
}
```

### 3.2. 初识渲染器

虚拟 DOM:

* 用 JS 对象来描述真实的 DOM 结构

渲染器：

* 将 虚拟 DOM 渲染为 真实 DOM

自定义渲染器：

```js
function renderer(vnode, container) {
  const {
    tag,
    props,
    children,
  } = vnode;

  const el = document.createElement(tag);

  for (const prop in props) {
    if (/^on/.test(prop)) {
      const eventName = prop.substr(2).toLowerCase();
      const handler = props[prop];

      el.addEventListener(eventName, handler);
    }
  }

  if (typeof children === 'string') {
    const text = document.createTextNode(children);
    el.appendChild(text);
  } else if (Array.isArray(children)) {
    children.forEach((child) => renderer(child, el));
  }

  container.appendChild(el);
}

// 使用
renderer({
  tag: 'div',
  props: {
    onClick: () => alert('hello'),
  },
  children: [
    { tag: 'span', children: '点我' }
  ]
}, document.body);
```

### 3.3. 组件的本质

说明：

* 组件就是一组 DOM 元素的封装，也是虚拟 DOM

组件：

```js
// 函数形式
const MyComponent = function() {
  return {
    tag: 'div',
    props: {
      onClick: () => alert('hello'),
    },
    children: [
      { tag: 'span', children: '点我' }
    ]
  };
};

// 对象形式
const MyComponent = {
  render: function() {
    return {
      tag: 'div',
      props: {
        onClick: () => alert('hello'),
      },
      children: [
        { tag: 'span', children: '点我' }
      ]
    };
  }
};
```

渲染器：

```js
function renderer(vnode, container) {
  const { tag } = vnode;

  if (typeof tag === 'string') {
    mountElement(vnode, container);
  } else if (typeof tag === 'function') {
    mountComponent(vnode, container);
  }
}

function mountElement(vnode, container) {
    const {
    tag,
    props,
    children,
  } = vnode;

  const el = document.createElement(tag);

  for (const prop in props) {
    if (/^on/.test(prop)) {
      const eventName = prop.substr(2).toLowerCase();
      const handler = props[prop];

      el.addEventListener(eventName, handler);
    }
  }

  if (typeof children === 'string') {
    const text = document.createTextNode(children);
    el.appendChild(text);
  } else if (Array.isArray(children)) {
    children.forEach((child) => renderer(child, el));
  }

  container.appendChild(el);
}

function mountComponent(vnode, container) {
  const subtree = vnode.tag(); // 获取 vnode
  renderer(subtree, container);
}
```

使用：

```js
const vnode = {
  tag: MyComponent,
};

renderer(vnode,  document.body)
```

### 3.4. 模板的工作原理

编译器：

* 将模板编译为渲染函数

示例：

* 模板：

    ```html
    <div @click="handler">
      click me
    </div>
    ```

* 渲染函数：

    ```js
    render() {
      return h('div', { onClick: handler }, 'click me');
    }
    ```

对于 `.vue` 文件，编译器会把 `<template>` 里的内容编译为 `render()` 函数，然后添加到组件对象上去