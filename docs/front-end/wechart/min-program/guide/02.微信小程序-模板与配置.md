# 微信小程序-模板与配置

目标：

* 能够使用 WXML 模板语法渲染页面结构
* 能够使用 WXSS 样式美化页面结构
* 能够使用 app.json 对小程序进行全局配置
* 能够使用 page.json 对小程序页面进行个性化配置
* 能够知道如何发起网络数据请求

目录：

* WXML 模板语法
* WXSS 模板样式
* 全局配置
* 页面配置
* 网络数据请求
* 案例 - 本地生活（首页）

## 1. WXML 模板语法

### 1.1. 数据绑定

基本原则：

1. 在 data 中定义数据
2. 在 WXML 中使用数据

在 data 中定义页面的数据：

```js
Page({
  data: {  
    person: { name: '张三', age: 18 }
  }
})
```

mustache 语法：

* 双花括号，插值表达式
* 示例:
  * index.wxml
    
    ```html
    <view>{{ message }}</view>
    ```

  * index.js

    ```js
    Page({
      data: {
        message: 'hello world'
      },
    })
    ```
    
mustache 语法的应用场景：

* 绑定内容
  * `<view>{{ message }}</view>`
* 绑定属性
  * `<image src="{{ src }}"></image>`
* 运算（JS 表达式）
  * `<view>{{ flag === '1' ? '显式' : '隐藏' }}</view>`

### 1.2. 事件绑定

事件：

* 事件是渲染层到逻辑层的通信方式
* 通过事件可以将用户在渲染产生的行为，反馈到逻辑层进行业务处理

常用事件：

| 类型     | 绑定方式                     | 描述                     |
|--------|--------------------------|------------------------|
| tap    | bindtap 或 bind:tap       | 手指触摸后马上离开，类似网页中的 click |
| input  | bindinput 或 bind:input   | 文本框的输入事件               |
| change | bindchange 或 bind:change | 状态改变时触发                |

事件对象的属性列表：

| 属性             | 类型     | 说明              |
|----------------|--------|-----------------|
| type           | string | 事件类型            |
| timeStamp      | number | 页面打开到触发事件的时间    |
| target         | object | 触发事件的组件的一些属性值集合 |
| currentTarget  | object | 当前组件的一些属性值集合    |
| detail         | object | 额外信息            |
| touches        | array  | 触摸事件，触摸点信息      |
| changedTouches | array  | 触摸事件，变化的触摸点信息   |


target 和 currentTarget 的区别：

* 事件会冒泡
* e.target 是触发事件的源头组件
* e.currentTarget 是侦听该事件的组件
* 示例

    ```html
    <!--
      点击按钮后，handleTap 被调用：
        e.target 是 button
        e.currentTarget 是 view
    -->
    <view bindtap="handleTap">
      <button>按钮</button>
    </view>
    ```

bindtap：

* 在小程序中，没有 onclick 事件，而是通过 tap 事件响应用户的触摸行为的
* 示例：
  * index.wxml

    ```html
    <button
      type="primary"
      bind:tap="handleTapButton"
    >
      按钮
    </button>
    ```

  * index.js

    ```js
    Page({
      handleTapButton(event) {
        console.log(event)
      }
    })
    ```

在事件处理函数中为 data 中的数据赋值：

* 读：`this.data.message`
* 写：`this.setData({ message: 'xxx' })`
* 示例：
  * index.wxml 

    ```html
    <view>{{ count }}</view>
    <button bind:tap="handleTapButton">按钮</button>
    ```

  * index.js
  
    ```js
    Page({
      data: {
        count: 0,
      },
      handleTapButton(event) {
        this.setData({
          count: this.data.count + 1
        })
      }
    })
    ```

事件传参：

* 通过 data-* 传参
* 传：`<view bind:tap="handleTap" data-message="{{ '娃哈哈' }}">`
* 取：`event.target.dataset.message`
* 示例：
  * index.wxml

      ```html
      <view>{{ count }}</view>
      <button bind:tap="handleTapButton" data-step="{{ 2 }}">按钮</button>
      ```
  * index.js

      ```js
      Page({
        data: {
          count: 0,
        },
        handleTapButton(event) {
          const { step } = event.target.dataset;
      
          this.setData({
            count: this.data.count + step
          })
        }
      })
      ```

bindinput：

* 类似于网页的 input 事件
* 通过 event.detail.value 拿到最新的（变化后）文本框的值
* 示例
  * index.wxml

      ```html
      <input bind:input="handleInput"></input>
      ```

  * index.js

      ```js
      Page({
        handleInput(event) {
          console.log('event.detail.value:', event.detail.value);
        }
      })
      ```

文本框与 data 之间的数据同步：

* 类似双向数据绑定
* 示例：
  * index.wxml

      ```html
      <input value="{{ message }}" bind:input="handleInput"></input>
      ```

  * index.js

      ```js
      Page({
        data: {
          message: '123'
        },
        handleInput(event) {
          this.setData({ message: event.detail.value })
        }
      })
      ```

### 1.3. 条件渲染

`wx:if`：

* 通过 `wx:if="{{ condition }}"` 判断是否需要渲染该代码块
* 示例：

    ```html
    <view wx:if="{{ gender === 1 }}">男</view>
    <view wx:elif="{{ gender === 2 }}">女</view>
    <view wx:else>保密</view>
    ```

`<block>`:

* 同时操作多个组件，且该组件不会被渲染
* 类似 vue 的 `<template>` 标签
* 示例

```html
<block wx:if="{{ gender === 1}}">
  <view>1</view>
  <view>2</view>
  <view>3</view>
</block>
```

hidden 属性：

* 通过 hidden 属性控制元素的显示与隐藏
* 内部通过 `display: none` 控制的，类似于 vue 的 v-show
* 示例：`<view hidden="{{ flag }}">娃哈哈</view>`

`wx:if` vs hidden:

* `wx:if` 通过动态 创建/移除 的方式控制元素的显示与隐藏
* hidden 通过 `display: none` 的方式控制元素的显示与隐藏

### 1.4. 列表渲染

`wx:for`：

* 循环渲染重复的组件结构
* 示例

    ```html
    <!--
      Page({
        data: {
          nums: [ 100, 200, 300 ]
        },
      })
    -->
    <view wx:for="{{ nums }}">
      {{ index }} - {{ item }}
    </view>
    ```
  
指定索引、当前项的名称：

* 通过 `wx:for-index`、`wx:for-item` 指定
* 示例

    ```html
    <view 
      wx:for="{{ nums }}"
      wx:for-index="i"
      wx:for-item="num"
    >
      {{ i }} - {{ num }}
    </view>
    ```
  
`wx:key`：

* 指定 key，提高渲染效率
* 示例：

    ```html
    <!--
      persons: [
        { id: 1, name: '张三' },
        { id: 2, name: '李四' },
        { id: 3, name: '王五' },
      ]
    -->
    <view wx:for="{{ persons }}" wx:key="id">
      {{ item.name }}
    </view>
    ```

## 2. WXSS 模板样式

什么是 WXSS：

* WeiXin Style Sheet
* 用于美化 WXML 的组件样式

WXSS 和 CSS 的关系：

* WXSS 具有 CSS 大部分特性
* WXSS 对 CSS 进行了扩充和修改
* 扩展的特性有：
  * `rpx`
  * `@import`

### 2.1. rpx

什么是 rpx 尺寸单位：

* responsive pixel
* 微信小程序独有的，用来解决屏幕适配的尺寸单位

rpx 的实现原理：

* 将屏幕宽度等分为 750 份，每一份为 1rpx，屏幕的宽度为 750rpx
* 小程序会自动将 rpx 换算为 px
* 建议设计师用 iPhone6 的屏幕尺寸作为视觉稿的标准，最好是 2 倍图

### 2.2. 样式导入

说明：

* 通过 `@import 相对路径` 导入外联样式表

示例：

* `@import '/common/common.wxss';`

### 2.3. 全局样式和局部样式

全局样式：

* 定义在 app.wxss 中的样式为全局样式，作用于每一个页面 

局部样式：

* 定义在页面的 .wxss 文件中样式为局部样式，只作用于当前页面
* 当局部和全局样式冲突时：
  * 权重大的生效
  * 相同权限，局部样式生效

## 3. 全局配置

全局配置文件：

* app.json 文件是小程序的全局配置文件

常用的配置项：

1. pages: 记录当前小程序所有页面的存放路径
2. window: 全局设置小程序窗口的外观
3. tabBar: 设置小程序底部的 tabBar 效果
4. style: 组件样式的版本

### window
