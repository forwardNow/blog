<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2024-01-24 11:23:31
@modify date 2024-01-24 11:23:32
@desc [description]
#endregion-->


# 移动端滑动方向判断

## 1. 介绍

移动端，滑动方向判断

## 2. 示例

```ts
interface IOptions {
  minDeltaDistance: number
}

function getDefaults(): IOptions {
  return {
    minDeltaDistance: 100,
  };
}

export enum Direction {
  Up = 'up',
  Down = 'down',
  Right = 'right',
  Left = 'left',
}

export class SwipeDetect {
  private el: HTMLElement;

  private options: IOptions;

  private listener: (d: Direction) => void;

  private startPoint = { x: 0, y: 0 };

  private endPoint = { x: 0, y: 0 };

  constructor(el: HTMLElement, listener: (d: Direction) => void, options = getDefaults()) {
    this.el = el;
    this.listener = listener;
    this.options = options;

    this.bindEvents();
  }

  private bindEvents() {
    this.el.addEventListener('touchstart', this.onTouchStart, false);
    this.el.addEventListener('touchmove', this.onTouchMove, false);
    this.el.addEventListener('touchend', this.onTouchEnd, false);
  }

  public destroy() {
    this.el.removeEventListener('touchstart', this.onTouchStart, false);
    this.el.removeEventListener('touchmove', this.onTouchMove, false);
    this.el.removeEventListener('touchend', this.onTouchEnd, false);

    this.el = null as any;
    this.options = null as any;
    this.listener = null as any;
  }

  private onTouchMove = (e: TouchEvent) => {
    // Prevent default will stop user from scrolling, use with care
    e.preventDefault();

    const touch = e.touches[0];
    this.endPoint.x = touch.screenX;
    this.endPoint.y = touch.screenY;
  };

  private onTouchStart = (e: TouchEvent) => {
    const touch = e.touches[0];
    this.startPoint.x = touch.screenX;
    this.startPoint.y = touch.screenY;
  };

  private onTouchEnd = () => {
    const deltaX = this.endPoint.x - this.startPoint.x;
    const deltaY = this.endPoint.y - this.startPoint.y;
    const { minDeltaDistance } = this.options;

    // Min swipe distance, you could use absolute value rather
    // than square. It just felt better for personal use
    if (deltaX ** 2 + deltaY ** 2 < minDeltaDistance ** 2) {
      return;
    }

    let direction: Direction;

    // horizontal
    if (deltaY === 0 || Math.abs(deltaX / deltaY) > 1) {
      direction = deltaX > 0 ? Direction.Right : Direction.Left;
    } else {
      // vertical
      direction = deltaY > 0 ? Direction.Down : Direction.Up;
    }

    this.listener(direction);

    direction = null as any;
  };
}
```

## 3. 参考

* [How to implement swipe gestures for mobile devices?](https://stackoverflow.com/questions/15084675/how-to-implement-swipe-gestures-for-mobile-devices)