# vue2

[[toc]]

## 1. 组件化

组件化是 vue 的核心思想，主要目的是为了**代码重用**。

## 2. 组件通信

### 2.1. 父组件 --> 子组件

属性（props）：

```javascript
// child
{
  props: {
    msg: String
  }
}

// parent
<Child msg="hello" />
```

引用（$refs）：

```jsx
// parent
<Child ref="childRef" />

const childVm = this.$refs.childRef;
```

子元素（$children）：

```javascript
// parent
const childVm = this.$children[0];

// 只针对唯一子组件有效，$children 不保证顺序
```

### 2.2. 子组件 --> 父组件

自定义事件：

```html
// child
this.$emit('add', { msg: 'hello' });

// parent
<Child @add="handleAdd" />
```

### 2.3. 兄弟组件

>通过共同的祖先组件作为中间人， `$parent` 或 `$root`

```javascript
// brother1
this.$parent.$on('add', handleAdd);

// brother2
this.$parent.$emit('add', { msg: 'hello' });
```

### 2.4. 祖先 --> 后代

>多用于组件库

provide / inject ： 祖先给后代传值（属性传值）

```javascript
// 祖先
{
  provide()
  {
    return {
      msg: 'hello'
    }
  }
}

// 后代
{
  inject: [
    'msg'
  ]
}
```

### 2.5. 任意两个组件

>事件总线 或 vuex

事件总线： 

```javascript
// bus.js
export default new Vue();

// 1.vue
import bus from './bus';

bus.$on('add', ({ msg }) => {
  console.log(msg);
})


// 2.vue
import bus from './bus';

bus.$emit('add', { msg: 'hello' });
```

vuex：创建唯一的全局数据管理者 store，通过它管理数据并通知组件状态变更。

## 3. 插槽

插槽语法是 Vue 实现的内容分发 API，用于复合组件开发。

该技术在通用组件库开发中有大量应用。

### 3.1. 匿名插槽

```vue
// child
<template>
  <div class="panel">
      <slot></slot>
  </div>
</template>

// parent
<Panel>
  内容
</Panel>
```

### 3.2. 具名插槽

将内容分发到指定的位置

```vue
// child
<template>
  <div class="panel">
    <slot name="body">内容</slot>
  </div>
</template>

// parent
<Panel>
  <template v-slot:body>
    内容xxx
  </template>
</Panel>
```

### 3.3. 作用域插槽

父组件使用子组件传递的数据

```html
// child
<template>
  <div class="panel">
    <slot name="test" :list="list"></slot>
  </div>
</template>
<script>
export default {
  data() {
    return {
      list: ['a', 'b', 'c']
    }
  }
}
</script>

// parent
<Panel>
  <template v-slot:test="{ list }">
    <div v-for="item in list" :key="item">{{ item }}</div>
  </template>
</Panel>
```

## 4. v-model 和 .sync

说明：

* 一般情况下，父组件传递的属性 子组件是无法修改的
* 但  `v-model` 和 `.sync` 可以。

区别：

* `v-model` 常用于表单元素或与表单元素相关的组件
* `.sync` 常用于非表单元素的组件

应用场景：

* 对话框

  * 父组件引入对话框（子组件）
  * 父组件通过属性绑定（`visible`）控制子组件的显示和隐藏
  * 子组件可以主动关闭自己，并通知父组件改变 `visible` 的值，避免父组件无法再次打开子组件的情况
  * 比如： [Dialog (visible.sync)—— element-ui](https://element.eleme.cn/#/en-US/component/dialog)

* 其他（待补充）

### 4.1. v-model

#### 4.1.1. 说明

* 双相绑定
  
  * `<input v-model="formInputValue">`

* 语法糖

  ```html
  v-model 就是使用 value（prop） 和 input（event）
  
  <input :value="formInputValue"
         @input="formInputValue = $event.target.value">
  ```  

* 也可用于自定义组件

  ```html
  // parent
  <Child v-model="parentValue" />
  
  // child
  props: ['value']
  this.$emit('input', newValue);
  ```

* 更改 v-model 的 prop 和 event

  ```html
  // child
  model: {
    prop: 'name', // value -> name
    event: 'updateName', // input -> updateName
  }
  ```

#### 4.1.2. 示例

> codes/vue2/02-src-v-model

* App.vue

  * <<< @/codes/vue2/02-src-v-model/App.vue
  
* Child.vue

  * <<< @/codes/vue2/02-src-v-model/Child.vue

* Child2.vue

  * <<< @/codes/vue2/02-src-v-model/Child2.vue

### 4.2. `.sync` 修饰符

说明：

* `.sync` 也是语法糖，省略了监听 `@update:xx`

示例：

* App.vue

  * <<< @/codes/vue2/03-src-sync/App.vue

* Child.vue

  * <<< @/codes/vue2/03-src-sync/Child.vue

## 5. 弹出层（弹窗）

说明：

* alert 、 confirm 等弹窗组件
* 它们在当前 Vue 实例之外独立存在，通常挂载到 body 
* 它们通过 JS 动态创建的，不需要在任何组件中声明

使用方式：

```javascript
const dialog = this.$dialog({ title: '提示', content: '确认删除？' });

dialog.show();
// dialog.hide();
```

示例：

* App.vue

  * <<< @/codes/vue2/04-src-dialog/App.vue

* Dialog.vue

  * <<< @/codes/vue2/04-src-dialog/Dialog.vue

* create.js

  * <<< @/codes/vue2/04-src-dialog/create.js

## 6. 递归组件

说明：

* 递归组件是可以在它们自己模板中调用自身的组件

条件：

* 组件有 `name` 属性
* 数据有 `children` 属性
* 收敛条件 `node.children && node.children.length > 0`

示例：

* App.vue

  * <<< @/codes/vue2/05-src-tree/App.vue

* Tree.vue

  * <<< @/codes/vue2/05-src-tree/Tree.vue

* TreeNode.vue

  * <<< @/codes/vue2/05-src-tree/TreeNode.vue

## 7. 路由

### 7.1. 基础

vue-cli 添加路由：

```shell
vue add router
```

指定路由器：

```javascript
new Vue({
  router,
  render: (h) => h(App),
}).$mount('#app');
```

路由视图：

```vue
<router-view />
```

路由链接：

```vue
<router-link to="/">home</router-link>
<router-link to="/about">about</router-link>
```

### 7.2. 路由传参

将路由参数直接设置到路由对应组件的 `props`

示例：

* router.js

  * <<< @/codes/vue2/06-src-router/router.js

* App.vue

  * <<< @/codes/vue2/06-src-router/App.vue

* Detail.vue

  * <<< @/codes/vue2/06-src-router/Detail.vue

### 7.3. 路由守卫

路由导航过程中有若干生命周期钩子，可以在这里实现逻辑控制。

全局前置守卫：

```javascript
const route = {
  path: '/foo',
  component: Foo,
  meta: { auth: true }, // auth 需要认证 
};

router.beforeEach((to, from ,next) => {
  if (to.meta.auth && !store.state.isLogin) {
    next({ name: 'Login' });
    return;
  }
  
  next();
});
```

单个路由独享的守卫：

```javascript
const route = {
  path: '/foo',
  component: Foo,
  beforeEnter: (to, from, next) => {
    // ...
  }
};
```

组件内的守卫：（hooks）

```javascript
const Foo = {
  template: `...`,
  beforeRouteEnter(to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate(to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave(to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}
```

### 7.4. 动态路由

利用 `$router.addRoutes()` 可以实现动态路由添加，常用于用户权限控制。

```javascript
const routersOfServer = [
  { 
    path: '/oa',
    component: 'oa', 
    children: [
      { path: '/oa/user-manage', component: 'oa.UserManage' }  
    ],
  },
  { 
    path: '/crm',
    component: 'crm', 
    children: [
      { path: '/crm/user-manage', component: 'crm.UserManage' }  
    ],
  },
];

// 异步获取路由
routerService.getRouters().then((routesOfServer) => {
  const routes = routesOfServer.map((route) => mapComponent(route));
  router.addRoutes(routes);
});

// 隐射关系
const componentsMap = {
  'oa': Oa,
  'oa.UserManager': Oa.UserMamager,
  'crm': Crm,
  'crm.UserManager': Crm.UserMamager,
};

// 递归替换
function mapComonent(route) {
  route.component = componentsMap[route.component];
  
  if (route.children) {
    route.children = route.children.map((childRoute) => mapComonent(childRoute));
  }
  
  return route;
}
```

## 8. 生命周期

父组件的 created 早于子组件

父组件的 mounted 晚于子组件
