# 内置模块常用API

## 1. path

### 1.1. 获取路径的最后一节

```javascript
path.basename('/foo/bar/baz/asdf/quux.html');
// Returns: 'quux.html'

path.basename('/foo/bar/baz/asdf/quux.html', '.html');
// Returns: 'quux'
```

### 1.2. 路径分隔符

```javascript
path.sep
```

## 2. fs

### 2.1. 重命名

`fs.renameSync(oldPath, newPath)`

* `oldPath`: String | Buffer | URL
* `newPath`: String | Buffer | URL

Renames the file from oldPath to newPath. Returns undefined.

### 2.2. 删除文件或目录

`fs.rmSync(path[, options])`

* `path`: String | Buffer | URL
* `options`: Object
    * `recursive`: boolean. If true, perform a recursive directory removal. In recursive mode, operations are retried on failure. Default: false. Deprecated.

Synchronously removes files and directories. Returns undefined.

### 2.3. 拷贝文件

`fs.copyFileSync(src, dest[, mode])`

* `src`: string.
* `dest`: string.

Synchronously copies src to dest. By default, dest is overwritten if it already exists. Returns undefined. 

### 2.4. 读取目录下的文件（夹）

`fs.readdirSync(path[, options])`

Reads the contents of the directory.

```javascript
fs.readdirSync(dirPath);
/*
[
    'dir1',
    'dir2',
    '1.txt',
    '2.txt'
]
*/
```

### 2.5. 判断是否目录

```javascript
fs.lstatSync(path_string).isDirectory() 

// Objects returned from fs.stat() and fs.lstat() are of this type.

stats.isFile()
stats.isDirectory()
stats.isBlockDevice()
stats.isCharacterDevice()
stats.isSymbolicLink() // (only valid with fs.lstat())
stats.isFIFO()
stats.isSocket()
```

### 2.6. 创建目录

```javascript
// fs.mkdirSync(path[, options])

// 创建单层目录
fs.mkdirSync('/a');

// 创建多层目录
fs.mkdirSync('a/b/c', { recursive: true });
```

### 2.7. 递归遍历目录中所有文件，并拷贝到其它目录

```javascript
const path = require('path');
const fs = require('fs');

// 遍历
const traverse = (dir, callback) => {
  const filenameList = fs.readdirSync(dir);

  for (let i = 0; i < filenameList.length; i++) {
    const filename = filenameList[i];

    const isDir = fs.lstatSync(filename).isDirectory();
    
    if (isDir) {
      const subDirPath = path.join(dir, filename);
      traverse(subDirPath, callback);
    }

    const filePath = path.join(dir, filename);

    callback(filePath, isDir);
  }
};

const srcRootPath = PROJ_DIST_PATH;
const destRootPath = WWW_PATH;

const copyFile = (filePath) => {
  const srcFilePath = filePath;
  const destFilePath = filePath.replace(srcRootPath, destRootPath);

  fs.copyFileSync(srcFilePath, destFilePath);
};

const copyDir = (dir) => {
  fs.mkdirSync(dir, { recursive: true });
};

traverse(srcRootPath, ({ filePath, isDir}) => {
  if (isDir) {
    copyDir(filePath);
    return;
  }

  copyFile(filePath);
});
```

## 3. os

### 3.1. 获取IPv4

```javascript
const os = require('os');

const v4Ips = [];
const networkInterfaces = os.networkInterfaces();

Reflect.ownKeys(networkInterfaces).forEach((netName) => {
  const networkInterfaceInfoList = networkInterfaces[netName];

  networkInterfaceInfoList.forEach((networkInterfaceInfo) => {
    const { family, internal, address } = networkInterfaceInfo;

    if (family === 'IPv4' && !internal) {
      v4Ips.push(address);
    }
  });
});
```

### 3.2. 获取 Home 目录

```javascript
os.homedir();// C:\Users\wuqinfei
```

## 4. child_process

>每一条指令是在不同的进程中执行的，`exec('cd ../../')` 是不能切换工作目录的

### 4.1. 执行脚本命令

* [child_process.exec(command[, options][, callback])](https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback)
* [child_process.execSync(command[, options])](https://nodejs.org/api/child_process.html#child_processexecsynccommand-options)

```javascript
const { exec } = require("child_process");

// options.cwd : 指定工作目录
function execCommand(command, options) {
  console.log(`start executing command: ${command}`);
  return new Promise((resolve, reject) => {
    exec(
      command, 
      (error, stdout, stderr) => {
        if (error) {
          reject(error);
          console.log(`[ ${command} ] error: ${error.message}`);
          return;
        }
        if (stderr) {
          reject(new Error(stderr));
          console.log(`[ ${command} ] stderr: ${stderr}`);
          return;
        }

        resolve(stdout);
        console.log(`[ ${command} ] stdout: ${stdout}`);
      }, 
      options,
    );
  });
}

async function run() {
  await execCommand('git pull', { cwd: 'xxx' });
  await execCommand('npm run build', { cwd: 'xxx' });
}
```