<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2025-07-25 21:01:17
@modify date 2025-07-25 22:54:52
@desc [description]
#endregion-->

# ssm - spring mvc

## 1. SpringMVC 概述

SpringMVC 是一种基于 Java 实现 MVC 模型的轻量级 Web 框架

## 2. SpringMVC 入门案例

### 2.1. 案例

(1) 步骤1: 创建 web 项目

maven 项目

maven-archetype-webapp

(2) 步骤2: 新建源码目录(java)

```text
${root}/
    src/main
        java      # 在项目结构设置中，新建 java 源码目录
```

(3) 步骤3: 导入 jar 包

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.example</groupId>
  <artifactId>01-springmvc-quickstart</artifactId>
  <packaging>war</packaging>
  <version>1.0-SNAPSHOT</version>

  <dependencies>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>5.2.10.RELEASE</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.tomcat.maven</groupId>
        <artifactId>tomcat7-maven-plugin</artifactId>
        <version>2.1</version>
        <configuration>
          <port>80</port>
          <path>/</path>
        </configuration>
      </plugin>
    </plugins>
  </build>

</project>
```

servlet 的坐标为什么需要添加 `<scope>provided</scope>` ?

* `scope` 是 maven 中 jar 包依赖作用范围的描述
* 如果不设置默认是 `compile` ，在编译、运行、测试时均有效
* 如果运行有效的话就会和 tomcat 中的 servlet-api 包发生冲突，导致启动报错
* `provided` 代表的是该包只在编译和测试的时候用，运行的时候无效；此时使用 tomcat 中的，就避免冲突

(4) 步骤4: 创建 SpringMVC 配置类

```java
@Configuration
@ComponentScan("org.example.controller")
public class SpringMvcConfig {
}
```

(5) 步骤5: 创建 Controller 类

```java
@Controller
public class UserController {
    @RequestMapping("/save")
    @ResponseBody
    public String save(){
        System.out.println("user save ...");
        return "{ 'info': 'springmvc' }";
    }
}
```

(6) 步骤6: 使用配置类替换 web.xml

将 web.xml 删除，换成 ServletContainersInitConfig

```java
// 该文件会自动扫描到
// web 容器配置类
public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {
    // 加载 springmvc 配置类
    protected WebApplicationContext createServletApplicationContext() {
        // 初始化 WebApplicationContext 对象
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
        // 加载指定配置类
        ctx.register(SpringMvcConfig.class);
        return ctx;
    }

    //设置由 springmvc 控制器处理的请求映射路径
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    //加载 spring 配置类
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }
}
```

(7) 步骤7: 启动项目

![image-20250725214131447](./images/image-20250725214131447.png)

(8) 步骤8: 浏览器访问

http://localhost/save

注意事项:

* SpringMVC 是基于 Spring 的，`spring-webmvc` jar包 自动依赖spring相关坐标
* `AbstractDispatcherServletInitializer` 类是 SpringMVC 提供的快速初始化 Web3.0 容器的抽象类
* `AbstractDispatcherServletInitializer` 提供了三个接口方法供用户实现
   * `createServletApplicationContext` 方法，创建 Servlet 容器时，加载 SpringMVC 对应的 bean 并放入 `WebApplicationContext` 对象范围中，而 `WebApplicationContext` 的作用范围为 `ServletContext` 范围，即整个 web 容器范围
  * `getServletMappings` 方法，设定 SpringMVC 对应的请求映射路径，即 SpringMVC 拦截哪些请求
  * `createRootApplicationContext` 方法，如果创建 Servlet 容器时需要加载非 SpringMVC 对应的 bean,使用当前方法进行，使用方式和 `createServletApplicationContext` 相同。
  * `createServletApplicationContext` 用来加载 SpringMVC 环境
  * `createRootApplicationContext` 用来加载 Spring 环境

### 2.2. 工作流程解析

#### 2.2.1. 启动服务器初始化过程

1. 服务器启动，执行 `ServletContainersInitConfig` 类，初始化 web 容器
    * 功能类似于以前的web.xml

2. 执行 `createServletApplicationContext` 方法，创建了 `WebApplicationContext` 对象
    * 该方法加载 SpringMVC 的配置类 SpringMvcConfig 来初始化 SpringMVC 的容器

3. 加载 `SpringMvcConfig` 配置类

4. 执行 `@ComponentScan` 加载对应的 bean
    * 扫描指定包及其子包下所有类上的注解，如 Controller 类上的 `@Controller` 注解

5. 加载 UserController，每个 `@RequestMapping` 的名称对应一个具体的方法
    * 此时就建立了 `/save` 和 save 方法的对应关系

6. 执行 `getServletMappings` 方法，设定 SpringMVC 拦截请求的路径规则
   * `/` 代表所拦截请求的路径规则，只有被拦截后才能交给 SpringMVC 来处理请求

#### 2.2.2. 单次请求过程

1. 发送请求 `http://localhost/save`
2. web 容器发现该请求满足 SpringMVC 拦截规则，将请求交给 SpringMVC 处理
3. 解析请求路径 `/save`
4. 由 `/save` 匹配执行对应的方法 `save()`
    * 上面的第 5 步已经将请求路径和方法建立了对应关系，通过 `/save` 就能找到对应的 `save()` 方法
5. 执行 save()
6. 检测到有 `@ResponseBody` 直接将 `save()` 方法的返回值作为响应体返回给请求方

### 2.3. bean 加载控制

#### 2.3.1. 问题分析

SpringMVC 加载的 bean:

* 表现层 的 bean (`@Controller`)

Spring 加载的 bean:

* 业务 bean (Service)
* 功能 bean
   * DataSource
   * SqlSessionFactoryBean
   * MapperScannerConfigurer

让 Spring 和 SpringMVC 分开加载各自的内容

#### 2.3.2. 思路分析

针对上面的问题，解决方案也比较简单，就是:

* 加载 Spring 控制的 bean 的时候排除掉 SpringMVC 控制的 bean

具体该如何排除：

* 方式一: Spring 加载的 bean 设定扫描范围为精准范围，例如 service包、dao包 等
* 方式二: Spring 加载的 bean 设定扫描范围为 org.example , 排除掉 controller 包中的 bean
* 方式三: 不区分 Spring 与 SpringMVC 的环境，加载到同一个环境中

#### 2.3.3. 示例

目录:

```text
${root}/
    src/main/java/
        org.example
            config/
                ServletContainersInitConfig.java
                SpringConfig.java
                SpringMvcConfig.java
            controller/
                UserController.java
            dao/
                UserDao.java
                impl/UserDaoImpl.java
            service/
                UserService.java
                impl/UserServiceImpl.java
```

```java
public interface UserDao {
    void save();
}

@Repository
public class UserDaoImpl implements UserDao {
    @Override
    public void save() {
        System.out.println("user dao save...");
    }
}

public interface UserService {
    void save();
}

@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserDao userDao;

    @Override
    public void save() {
        userDao.save();
        System.out.println("user service save...");
    }
}

@Controller
public class UserController {
    @Autowired
    private UserService userService;

    @RequestMapping("/save")
    @ResponseBody
    public String save(){
        userService.save();
        return "{ 'info': 'springmvc' }";
    }
}
```

```java
@Configuration
@ComponentScan({"org.example.service","org.example.dao"})
public class SpringConfig {
}

@Configuration
@ComponentScan("org.example.controller")
public class SpringMvcConfig {
}

// 这个类作为入口，加载 spring 、springmvc 的配置类
public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {
    // 加载 springmvc 配置类
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
        ctx.register(SpringMvcConfig.class);
        return ctx;
    }

    // 设置由 springmvc 控制器处理的请求映射路径
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    // 加载 spring 配置类
    protected WebApplicationContext createRootApplicationContext() {
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
        ctx.register(SpringConfig.class);
        return ctx;
    }
}
```

`ServletContainersInitConfig` 的更简便写法:

```java
public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {

    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```