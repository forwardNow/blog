<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2025-07-09 21:21:12
@modify date 2025-07-11 20:17:53
@desc [description]
#endregion-->

# SSM

## 1. spring

### 1.1. 核心概念

(1) 什么IOC/DI思想?

IOC : 控制反转，控制反转的是对象的创建权

DI : 依赖注入，绑定对象与对象之间的依赖关系


(2) 什么是 IOC 容器?

Spring 创建了一个容器用来存放所创建的对象，这个容器就叫 IOC 容器


(3) 什么是 Bean?

容器中所存放的一个个对象就叫 Bean 或 Bean对象

### 1.2. 入门案例

目录:

```text
${root}
  src/main
      java/
          org/example
              App.java
              BookDao.java
              BookDaoImpl.java
              BookService.java
              BookServiceImpl.java
      resources/
          applicationContext.xml
          
  pom.xml
```

pom.xml:

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.2.10.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

resources/applicationContext.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="org.example.BookDaoImpl"/>

    <bean id="bookService" class="org.example.BookServiceImpl">
        <property name="bookDao" ref="bookDao"/>
    </bean>

</beans>
```

class:

```java
public class App {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");

        BookService bookService = (BookService) ctx.getBean("bookService");
        bookService.save();
    }
}

public interface BookDao {
    public void save();
}
public class BookDaoImpl implements BookDao {
    public void save() {
      System.out.println("book dao save ...");
    }
}

public interface BookService {
    public void save();
}
public class BookServiceImpl implements BookService {
    private BookDao bookDao;

    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }

}
```

### 1.3. IOC 相关

#### 1.3.1. bean 基础配置

```xml
<!-- 
  id: 必须唯一
  class: 指定实现类的全名，不可以写接口
  name: 指定别名，可定义多个，分隔符: 空格、分号、空格
  scope: "singleton" (单例，默认) | "prototype" (非单例)
 -->
<bean 
  id="bookDao"
  class="org.example.quickstart.BookDaoImpl"

  name="bookDao1, bookDao2"

  scope="singleton"
/>
```

#### 1.3.2. bean 实例化

(1) 方式一: （无参）构造函数 实例化 bean

类:

```java
// 实现类
public class BookDaoImpl implements BookDao {
    public void save() {
        System.out.println("book dao save ...");
    }
}
```

配置:

```xml
<bean id="bookDao" class="org.example.BookDaoImpl"/>
```

使用:

```java
BookDao bookDao = (BookDao) ctx.getBean("bookDao");
bookDao.save();
```


(2) 方式二: 静态工厂 实例化 bean

类:

```java
// 静态工厂类
public class OrderDaoFactory {
    public static OrderDao getOrderDao(){
        return new OrderDaoImpl();
    }
}

// 实现类
public class OrderDaoImpl implements OrderDao {
    public void save() {
        System.out.println("order dao save ...");
    }
}
```

配置:

```xml
<bean id="orderDao" class="org.example.OrderDaoFactory" factory-method="getOrderDao" />
```

使用:

```java
OrderDao orderDao = (OrderDao) ctx.getBean("orderDao");
orderDao.save();
```


(3) 方式三: 实例工厂 实例化 bean

类:

```java
// 实例工厂类
public class UserDaoFactory {
    public UserDao getUserDao(){
        return new UserDaoImpl();
    }
}

// 实现类
public class UserDaoImpl implements UserDao {
    public void save() {
        System.out.println("user dao save ...");
    }
}
```

配置:

```xml
<bean id="userFactory" class="org.example.UserDaoFactory"/>
<bean id="userDao" factory-method="getUserDao" factory-bean="userFactory"/>
```

使用:

```java
UserDao userDao = (UserDao) ctx.getBean("userDao");
userDao.save();
```


(4) 方式四: FactoryBean 实例化 bean

类:

```java
// 工厂类
public class UserDaoFactoryBean implements FactoryBean<UserDao> {
    @Override
    public UserDao getObject() throws Exception {
        return new UserDaoImpl(); // 返回 bean
    }

    @Override
    public Class<?> getObjectType() {
        return UserDao.class; // 指定 bean 的类型
    }
}
```

配置:

```xml
<bean id="userDao2" class="org.example.UserDaoFactoryBean" />
```

使用:

```java
UserDao userDao = (UserDao) ctx.getBean("userDao2");
userDao.save();
```

#### 1.3.3. bean 的生命周期

(1) 关于 Spring 中对 bean 生命周期控制提供了两种方式:

* 在配置文件中的 bean 标签中添加 `init-method` 和 `destroy-method` 属性
* 类实现 `InitializingBean` 与 `DisposableBean` 接口

```xml
<bean id="bookDao" class="org.example.BookDaoImpl" init-method="init" destroy-method="destroy" />

<bean id="userDao" class="org.example.UserDaoImpl"/>
```

```java
public class App {
    public static void main(String[] args) {
        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");

        BookDaoImpl bookDao = (BookDaoImpl) ctx.getBean("bookDao");
        bookDao.save();
        UserDaoImpl userDao = (UserDaoImpl) ctx.getBean("userDao");
        userDao.save();

        // ctx.close();
        ctx.registerShutdownHook();
    }
}

public class BookDaoImpl {
    public void save() {
        System.out.println("book dao save ...");
    }

    public void init() {
        System.out.println("book dao init ...");
    }
    public void destroy() {
        System.out.println("book dao destroy ...");
    }
}

public class UserDaoImpl implements InitializingBean, DisposableBean {
    public void save() {
        System.out.println("user dao save ...");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("user dao init ...");
    }
    @Override
    public void destroy() throws Exception {
        System.out.println("user dao destroy ...");
    }

}
```

(2) 对于 bean 的生命周期控制在 bean 的整个生命周期中所处的位置如下:

1. 初始化容器:
  1. 创建对象(内存分配)
  2. 执行构造方法
  3. 执行属性注入(set操作)
  4. 执行bean初始化方法

2. 使用 bean
  * 执行业务操作

3. 关闭/销毁容器
  * 执行 bean 销毁方法


(3) 关闭容器的两种方式:

* ConfigurableApplicationContext 是 ApplicationContext 的子类
* close() 方法
* registerShutdownHook() 方法

### 1.4. DI 相关内容

#### 1.4.1. setter 注入

```xml
<bean id="bookDao" class="org.example.BookDaoImpl" />

<bean id="bookService" class="org.example.BookServiceImpl">
    <!-- 注入 引用类型 -->
    <property name="bookDao" ref="bookDao" />

    <!-- 注入 简单类型 -->
    <property name="name" value="ZhangSan" />
    <property name="num" value="18" />
</bean>
```

```java
public class BookServiceImpl {
    private BookDaoImpl bookDao;
    private String name;
    private int num;

    public void setBookDao(BookDaoImpl bookDao) {
        this.bookDao = bookDao;
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setNum(int num) {
        this.num = num;
    }

    public void save() {
        bookDao.save();
        System.out.println("book service save ... name=" + name + ", num=" + num);
    }
}
```

#### 1.4.2. 构造器注入

```xml
<bean id="bookDao" class="org.example.BookDaoImpl" />

<bean id="bookService" class="org.example.BookServiceImpl">
    <!-- name 为形参的名称 -->
    <constructor-arg name="bookDao" ref="bookDao" />
    <constructor-arg name="name" value="ZhangSan" />
    <constructor-arg name="num" value="20" />
</bean>

```

```java
public class BookServiceImpl {
    private BookDaoImpl bookDao;
    private String name;
    private int num;

    public BookServiceImpl(BookDaoImpl bookDao, String name, int num) {
        this.bookDao = bookDao;
        this.name = name;
        this.num = num;
    }

    public void save() {
        bookDao.save();
        System.out.println("book service save ... name=" + name + ", num=" + num);
    }
}
```

介绍完两种参数的注入方式，具体我们该如何选择呢?

1. 强制依赖使用构造器进行，使用 setter 注入有概率不进行注入导致 null 对象出现
   * 强制依赖指对象在创建的过程中必须要注入指定的参数
2. 可选依赖使用 setter 注入进行，灵活性强
   * 可选依赖指对象在创建过程中注入的参数可有可无
3. Spring 框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨
4. 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用 setter 注入完成可选依赖的注入
5. 实际开发过程中还要根据实际情况分析，如果受控对象没有提供 setter 方法就必须使用构造器注入
6. 自己开发的模块推荐使用 setter 注入