<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2025-08-04 23:38:14
@modify date 2025-08-18 20:14:09
@desc [description]
#endregion-->

# jdk8 新特性

## 1. 概述

Open JDK 与 Oracle JDK:

* 大多数 JDK 都是基于 Open JDK 开发的，比如 Oracle JDK
* Open JDK 官网: https://openjdk.org/
* 2019年发布的 Oracle Java SE 需要商业授权

## 2. Lambda

### 2.1. 体验

```java
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("匿名内部类...");
    }
}).start();

new Thread(() -> {
    System.out.println("Lambda表达式...");
}).start();
```

Lambda 表达式的好处: 简化匿名内部类的书写

### 2.2. 无参数无返回值的 Lambda

说明:

* 调用的方法中，有个参数是接口类型，可以考虑使用 Lambda 表达式

示例:

```java
public interface Swimmable {
    void swimming();
}


public class Lambda_02_use {
    public static void main(String[] args) {
        goSwimming(new Swimmable() {
            @Override
            public void swimming() {
                System.out.println("匿名内部类");
            }
        });

        goSwimming(() -> {
            System.out.println("Lambda");
        });
    }

    public static void goSwimming(Swimmable swimmable) {
        swimmable.swimming();
    }
}
```

### 2.3. 有参数有返回值的 Lambda

示例1:

```java
public interface Smokable {
    int smoking(String name);
}


public class Lambda_03_arg_ret {
    public static void main(String[] args) {
        goSmoking(new Smokable() {
            @Override
            public int smoking(String name) {
                System.out.println("匿名内部类 " + name);
                return 1;
            }
        });

        goSmoking((String name) -> {
            System.out.println("Lambda " + name);
            return 2;
        });
    }

    public static void goSmoking(Smokable s) {
        int num = s.smoking("中华");
        System.out.println("返回值: " + num);
    }
}
```

示例2, 对象列表排序:

```java
public class Person {
    public String name;
    public int age;
    // ...
}


public class Lambda_04_集合排序 {
    public static void main(String[] args) {
        List<Person> personList = new ArrayList<>();

        personList.add(new Person("张三", 20));
        personList.add(new Person("李四", 40));
        personList.add(new Person("王五", 30));

        // sortList1(personList);
        sortList2(personList);
        
        for (Person p : personList) {
            System.out.println(p);
        }
    }

    private static void sortList1(List<Person> personList) {
        personList.sort(new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.age - o2.age;
            }
        });

    }

    private static void sortList2(List<Person> personList) {
        personList.sort((o1, o2) -> {
            return o1.age - o2.age;
        });
    }
}
```

### 2.4. Lambda 简写形式

规则:

1. 可省略(小括号内的)参数类型 
2. 如果只有一个形参，则小括号可以省略
2. 如果方法体只有一个语句，则可以省略 花括号、return、分号

示例:

```java
(int num) -> {
    return num + 1;
};

// 1
(num) -> {
    return num + 1;
};

// 2
num -> {
    return num + 1;
};

// 3
num -> num + 1;
```

### 2.5. 使用 Lambda 的前提条件

前提条件:

1. Lambda 表达式只能用于 接口类型形参、变量
2. 接口中有且仅有一个（抽象）方法

说明:

* 在只有一个方法的接口上，使用 `@FunctionalInterface`

示例:

```java
public class Lambda_05_前提条件 {
    public static void main(String[] args) {
        goFlying(() -> System.out.println("Flying ..."));

        Flyable f = () -> System.out.println("Flying ...");
    }

    public static void goFlying(Flyable f) {
        f.flying();
    }
}

// 该注解，标记该接口是函数式接口（只有一个抽象方法的接口）
@FunctionalInterface
interface Flyable {
    void flying();
    // void method();
}

```

## 3. 接口新增的方法

JDK 8 之前的 接口:

```java
interface 接口名称 {
    静态常量;
    抽象方法;
}
```

JDK 8 的 接口:

```java
interface 接口名称 {
    静态常量;
    抽象方法;

    默认方法;
    静态方法;
}
```

### 3.1. 接口的默认方法

说明:

1. 使用 `default` 关键字
1. 实现类，相当于继承该 默认方法，可以直接使用也可以重写

示例:

```java
public class Lambda_06_接口的默认方法 {
    public static void main(String[] args) {
        new Person().eating("大米");
        new Dog().eating("肉");
    }
}

interface Eatable {
    default void eating(String food) {
        System.out.println("eating " + food);
    }
}

// 实现类直接使用默认方法
class Person implements Eatable {
}

// 实现类重写默认方法
class Dog implements Eatable {
    @Override
    public void eating(String food) {
        System.out.println("Dog is eating" + food);
    }
}
```

### 3.2. 接口的静态方法

说明:

* 可以在接口里使用静态方法
* 只能通过接口名称来调用，实现类不能重写

示例:

```java
public class Lambda_07_接口的静态方法 {
    public static void main(String[] args) {
        IMyInterface.print();
    }
}

interface IMyInterface {
    static void print() {
        System.out.println("我是接口的静态方法");
    }
}
```

## 4. 内置函数式接口

### 4.1. Supplier

供给接口，无参数有返回值

```java
@FunctionalInterface
public interface Supplier<T> {
    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}
```

示例:

```java
public class Inner_lambda_Supplier {
    public static void main(String[] args) {
        printNum(() -> 100);
    }

    public static void printNum(Supplier<Integer> supplier) {
        Integer num = supplier.get();
        System.out.println(num);
    }
}
```

### 4.2. Consumer

消费接口，有参数无返回值

```java
@FunctionalInterface
public interface Consumer<T> {
    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);

    default Consumer<T> andThen(Consumer<? super T> after) {
        Objects.requireNonNull(after);
        return (T t) -> { accept(t); after.accept(t); };
    }
}
```

示例:

```java
public class InnerLambda_02_Consumer {
    public static void main(String[] args) {
        printStr(
            (str) -> System.out.println(str.toLowerCase()),
            (str) -> System.out.println(str.toUpperCase())
        );
    }

    public static void printStr(Consumer<String> consumer1, Consumer<String> consumer2) {
        String str = "Hello World";
        consumer1.andThen(consumer2).accept(str);
    }
}
```

### 4.3. Function

有参数，有返回值

```java
@FunctionalInterface
public interface Function<T, R> {
    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);

    default Consumer<T> andThen(Consumer<? super T> after) {
        Objects.requireNonNull(after);
        return (T t) -> { accept(t); after.accept(t); };
    }
}
```

示例:

```java
public class InnerLambda_03_Function {
    public static void main(String[] args) {
        strToNum((str) -> Integer.parseInt(str) * 2);
    }

    public static void strToNum(Function<String, Integer> f) {
        String str = "123";
        System.out.println(f.apply(str));
    }
}
```

### 4.4. Predicate

有参数，有返回值

```java
@FunctionalInterface
public interface Predicate<T, R> {
    /**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return {@code true} if the input argument matches the predicate,
     * otherwise {@code false}
     */
    boolean test(T t);

    default Predicate<T> and(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) && other.test(t);
    }

    default Predicate<T> or(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) || other.test(t);
    }

    default Predicate<T> negate() {
        return (t) -> !test(t);
    }
}
```

示例:

```java
public class InnerLambda_04_Predicate {
    public static void main(String[] args) {
        test(
                (str) -> str.contains("H"),
                (str) -> str.contains("W")
        );
    }

    public static void test(Predicate<String> predicate1, Predicate<String> predicate2) {
        if (predicate1.and(predicate2).test("Hello World")) {
            System.out.println("包含 H 且 包含 W");
        }

        if (predicate1.or(predicate2).test("Hello")) {
            System.out.println("包含 H 或 包含 W");
        }

        if (predicate1.negate().test("World")) {
            System.out.println("不包含 H");
        }
    }
}
```

## 5. 方法引用

如果 Lambda 方法体里只有一个 调用其他的方法 的语句，则可以简写

常见的引用方式:

* 对象::方法名
* 类名::静态方法名
* 类名::普通方法名
* 类名::new
* 数组::new

### 5.1. 对象::方法名

示例:

```java
Date date = new Date();

Supplier<Long> supplier1 = () -> date.getTime();

// 简写
Supplier<Long> supplier2 = date::getTime;
```

### 5.2. 类名::静态方法名

```java
Supplier<Long> supplier1 = () -> System.currentTimeMillis();

// 简写
Supplier<Long> supplier2 = System::currentTimeMillis;
```

### 5.3. 类名::普通方法名

说明:

* 第一个参数为 方法的调用者，后续的参数为方法的参数

示例:

```java
Function<String, Integer> getStringLength1 = (String str) -> {
    return str.length();
};

// 简写
Function<String, Integer> getStringLength2 = String::length;

System.out.println(getStringLength1.apply("123"));
System.out.println(getStringLength2.apply("1234"));



BiFunction<String, Integer, String> substr1 = (String str, Integer beginIndex) -> {
    return str.substring(beginIndex);
};

// 简写
BiFunction<String, Integer, String> substr2 = String::substring;

System.out.println(substr1.apply("0123456", 3));
System.out.println(substr2.apply("0123456", 3));
```

### 5.4. 类名::new

调用类的构造器方法

示例:

```java
// -- 无参构造器

Supplier<Person> supplier1 = () -> {
    return new Person();
};

// 简写
Supplier<Person> supplier2 = Person::new;


// -- 有参构造器

BiFunction<String, Integer, Person>  biFunction1 = (String name, Integer age) -> {
    return new Person(name, age);
};

// 简写
BiFunction<String, Integer, Person>  biFunction2 = Person::new;
```

### 5.5. 数组::new

调用数组的构造方法

* 类型[]::new

示例:

```java
Function<Integer, String[]> function1 = (Integer length) -> {
    return new String[length];
};

// 简写
Function<Integer, String[]> function2 = String[]::new;
```

## 6. stream 流

### 6.1. 创建方式

方式:

1. 通过 Collection.stream() 方法获取流
2. 通过 Stream.of(T... values) 方法

示例:

```java
// 1. 通过 Collection.stream() 方法获取流

List<String> list = new ArrayList<>();
Set<String> set = new HashSet<>();
Map<String, String> map = new HashMap<>();

Stream<String> listStream = list.stream();
Stream<String> setStream = set.stream();
Stream<String> mapValuesStream = map.values().stream();
Stream<String> mapKeysStream = map.keySet().stream();
Stream<Map.Entry<String, String>> mapEntriesStream = map.entrySet().stream();


// 2. 通过 Stream.of(T... values) 方法

String[] strArr = { "a", "b" };
Stream<String> strArrStream = Stream.of(strArr);

Integer[] integerArr = { 1, 2 };
Stream<Integer> integerArrStream = Stream.of(integerArr);
```

### 6.2. 常用方法与注意事项

常用方法:

| 方法名 | 作用 | 返回值类型 | 类别 |
| - | - | - | - |
| count | 统计个数 | long | 终结 |
| forEach | 遍历 | void | 终结 |
| filter | 过滤 | Stream | 函数拼接 |
| limit | 取前几个 | Stream | 函数拼接 |
| skip | 跳过前几个 | Stream | 函数拼接 |
| map | 隐射 | Stream | 函数拼接 |
| concat | 组合 | Stream | 函数拼接 |

类别:

* 终结: 返回值不是 Stream 类型的方法，不支持链式调用
* 函数拼接: 返回值是 Stream 类型的方法，支持链式调用

注意事项:

1. Stream 流只能被操作一次
2. 函数拼接方法返回的是新流
3. 不调用终结方法，Stream 链中的操作不会执行

### 6.3. forEach()

方法:

* `void forEach(Consumer<? super T> action);`

示例:

```java
List<String> list = new ArrayList<>();
Collections.addAll(list, "张三", "李四", "王五");

list.stream().forEach((String item) -> {
    System.out.println(item);
});

// 简写
list.stream().forEach(item -> System.out.println(item));

// 方法调用
list.stream().forEach(System.out::println);
```

### 6.4. count()

计数

```java
List<String> list = new ArrayList<>();
Collections.addAll(list, "张三", "李四", "王五");

long count = list.stream().count();

System.out.println(count);
```

### 6.5. filter

过滤

```java
List<String> list = new ArrayList<>();
Collections.addAll(list, "张三", "李四", "王五");

list.stream()
        .filter(item -> item.contains("李"))
        .forEach(System.out::println);
```

### 6.6. limit()

获取前 N 个

```java
List<String> list = new ArrayList<>();
Collections.addAll(list, "张三", "李四", "王五");

list.stream()
        .limit(2)
        .forEach(System.out::println);
```

### 6.7. skip()

跳过前 N 个

```java
List<String> list = new ArrayList<>();
Collections.addAll(list, "张三", "李四", "王五");

list.stream()
        .skip(2)
        .forEach(System.out::println);
```

### 6.8. map()

将一种类型的流转换成另一种类型的流

```java
Stream<String> stringStream = Stream.of("111", "222", "333");

Stream<Integer> integerStream = stringStream.map(Integer::parseInt);

integerStream.forEach(System.out::println);
```

### 6.9. sorted()

排序

```java
// 无参，字典顺序，升序
Stream.of(2, 1, 3)
        .sorted()
        .forEach(System.out::println);

// 有参
// Comparator<? super T> comparator
//     int compare(T o1, T o2);
Stream.of(2, 1, 3)
        .sorted((num1, num2) -> num2 - num1) // 降序
        .forEach(System.out::println);
```

### 6.10. distinct()

去重

```java
// 数字去重
Stream<Integer> integerStream = Stream.of(1, 2, 2, 3);
integerStream.distinct().forEach(System.out::println);

// 字符串去重
Stream<String> stringStream = Stream.of("11", "22", "22", "33");
stringStream.distinct().forEach(System.out::println);

// 对象去重: 需要重写 equals() 和 hashCode()
Stream<Person> personStream = Stream.of(
        new Person("张三"),
        new Person("张三"),
        new Person("李四"),
        new Person("李四")
);
personStream.distinct().forEach(System.out::println);
```