<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2025-08-04 23:38:14
@modify date 2025-08-16 11:11:30
@desc [description]
#endregion-->

# jdk8 新特性

## 1. 概述

Open JDK 与 Oracle JDK:

* 大多数 JDK 都是基于 Open JDK 开发的，比如 Oracle JDK
* Open JDK 官网: https://openjdk.org/
* 2019年发布的 Oracle Java SE 需要商业授权

## 2. Lambda

### 2.1. 体验

```java
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("匿名内部类...");
    }
}).start();

new Thread(() -> {
    System.out.println("Lambda表达式...");
}).start();
```

Lambda 表达式的好处: 简化匿名内部类的书写

### 2.2. 无参数无返回值的 Lambda

说明:

* 调用的方法中，有个参数是接口类型，可以考虑使用 Lambda 表达式

示例:

```java
public interface Swimmable {
    void swimming();
}


public class Lambda_02_use {
    public static void main(String[] args) {
        goSwimming(new Swimmable() {
            @Override
            public void swimming() {
                System.out.println("匿名内部类");
            }
        });

        goSwimming(() -> {
            System.out.println("Lambda");
        });
    }

    public static void goSwimming(Swimmable swimmable) {
        swimmable.swimming();
    }
}
```

### 2.3. 有参数有返回值的 Lambda

示例1:

```java
public interface Smokable {
    int smoking(String name);
}


public class Lambda_03_arg_ret {
    public static void main(String[] args) {
        goSmoking(new Smokable() {
            @Override
            public int smoking(String name) {
                System.out.println("匿名内部类 " + name);
                return 1;
            }
        });

        goSmoking((String name) -> {
            System.out.println("Lambda " + name);
            return 2;
        });
    }

    public static void goSmoking(Smokable s) {
        int num = s.smoking("中华");
        System.out.println("返回值: " + num);
    }
}
```

示例2, 对象列表排序:

```java
public class Person {
    public String name;
    public int age;
    // ...
}


public class Lambda_04_集合排序 {
    public static void main(String[] args) {
        List<Person> personList = new ArrayList<>();

        personList.add(new Person("张三", 20));
        personList.add(new Person("李四", 40));
        personList.add(new Person("王五", 30));

        // sortList1(personList);
        sortList2(personList);
        
        for (Person p : personList) {
            System.out.println(p);
        }
    }

    private static void sortList1(List<Person> personList) {
        personList.sort(new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.age - o2.age;
            }
        });

    }

    private static void sortList2(List<Person> personList) {
        personList.sort((o1, o2) -> {
            return o1.age - o2.age;
        });
    }
}
```

### 2.4. Lambda 简写形式

规则:

1. 可省略(小括号内的)参数类型 
2. 如果只有一个形参，则小括号可以省略
2. 如果方法体只有一个语句，则可以省略 花括号、return、分号

示例:

```java
(int num) -> {
    return num + 1;
};

// 1
(num) -> {
    return num + 1;
};

// 2
num -> {
    return num + 1;
};

// 3
num -> num + 1;
```

### 2.5. 使用 Lambda 的前提条件

前提条件:

1. Lambda 表达式只能用于 接口类型形参、变量
2. 接口中有且仅有一个（抽象）方法

说明:

* 在只有一个方法的接口上，使用 `@FunctionalInterface`

示例:

```java
public class Lambda_05_前提条件 {
    public static void main(String[] args) {
        goFlying(() -> System.out.println("Flying ..."));

        Flyable f = () -> System.out.println("Flying ...");
    }

    public static void goFlying(Flyable f) {
        f.flying();
    }
}

// 该注解，标记该接口是函数式接口（只有一个抽象方法的接口）
@FunctionalInterface
interface Flyable {
    void flying();
    // void method();
}

```

## 3. 接口新增的方法

JDK 8 之前的 接口:

```java
interface 接口名称 {
    静态常量;
    抽象方法;
}
```

JDK 8 的 接口:

```java
interface 接口名称 {
    静态常量;
    抽象方法;

    默认方法;
    静态方法;
}
```

### 3.1. 接口的默认方法

说明:

1. 使用 `default` 关键字
1. 实现类，相当于继承该 默认方法，可以直接使用也可以重写

示例:

```java
public class Lambda_06_接口的默认方法 {
    public static void main(String[] args) {
        new Person().eating("大米");
        new Dog().eating("肉");
    }
}

interface Eatable {
    default void eating(String food) {
        System.out.println("eating " + food);
    }
}

// 实现类直接使用默认方法
class Person implements Eatable {
}

// 实现类重写默认方法
class Dog implements Eatable {
    @Override
    public void eating(String food) {
        System.out.println("Dog is eating" + food);
    }
}
```

### 3.2. 接口的静态方法

说明:

* 可以在接口里使用静态方法
* 只能通过接口名称来调用，实现类不能重写

示例:

```java
public class Lambda_07_接口的静态方法 {
    public static void main(String[] args) {
        IMyInterface.print();
    }
}

interface IMyInterface {
    static void print() {
        System.out.println("我是接口的静态方法");
    }
}
```

## 4. 内置函数式接口

### 4.1. Supplier

供给接口，无参数有返回值

```java
@FunctionalInterface
public interface Supplier<T> {
    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}
```

示例:

```java
public class Inner_lambda_Supplier {
    public static void main(String[] args) {
        printNum(() -> 100);
    }

    public static void printNum(Supplier<Integer> supplier) {
        Integer num = supplier.get();
        System.out.println(num);
    }
}
```

### 4.2. Consumer

消费接口，有参数无返回值

```java
@FunctionalInterface
public interface Consumer<T> {
    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);

    default Consumer<T> andThen(Consumer<? super T> after) {
        Objects.requireNonNull(after);
        return (T t) -> { accept(t); after.accept(t); };
    }
}
```

示例:

```java
public class InnerLambda_02_Consumer {
    public static void main(String[] args) {
        printStr(
            (str) -> System.out.println(str.toLowerCase()),
            (str) -> System.out.println(str.toUpperCase())
        );
    }

    public static void printStr(Consumer<String> consumer1, Consumer<String> consumer2) {
        String str = "Hello World";
        consumer1.andThen(consumer2).accept(str);
    }
}
```

### 4.3. Function

有参数，有返回值

```java
@FunctionalInterface
public interface Function<T, R> {
    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);

    default Consumer<T> andThen(Consumer<? super T> after) {
        Objects.requireNonNull(after);
        return (T t) -> { accept(t); after.accept(t); };
    }
}
```

示例:

```java
public class InnerLambda_03_Function {
    public static void main(String[] args) {
        strToNum((str) -> Integer.parseInt(str) * 2);
    }

    public static void strToNum(Function<String, Integer> f) {
        String str = "123";
        System.out.println(f.apply(str));
    }
}
```
