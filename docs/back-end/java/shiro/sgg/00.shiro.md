<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2025-08-27 21:02:37
@modify date 2025-08-28 21:33:39
@desc [description]
#endregion-->

# shiro

## 1. 入门概述

### 1.1. 是什么

Apache Shiro 是 Java 安全（权限）框架。

功能:

* 认证
* 授权
* 加密
* 会话管理
* 与 Web 集成
* 缓存

### 1.2. 为什么要用 Shiro

* 易于使用
* 全面
* 灵活
* 强力支持 Web
* 兼容性强

### 1.3. 与 Spring Security 的对比

* Spring Security 基于 Spring，更方便、强大，社区资源也更好
* Shiro 不依赖 Spring，在集群中 会话 独立于容器

### 1.4. 基本功能

![image-20250827210931859](./images/image-20250827210931859.png)

![image-20250827212610684](./images/image-20250827212610684.png)


![image-20250827212658646](./images/image-20250827212658646.png)

## 2. 基本使用

### 2.1. 环境准备

1. 创建普通 Java 工程（选择 Maven 构建）

2. 添加依赖

    ```xml
    <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-core</artifactId>
        <version>1.9.0</version>
    </dependency>
    
    <dependency>
        <groupId>commons-logging</groupId>
        <artifactId>commons-logging</artifactId>
        <version>1.2</version>
    </dependency>
    ```

### 2.2. ini 文件

Shiro 获取权限相关信息可以通过数据库，也可以通过 ini 配置文件

位置:

```text
${root}/
  src/main/resources
    shiro.ini
```

shiro.ini:

```ini
[users]
zhangsan=123
lisi=456
```

### 2.3. 登录认证

#### 2.3.1. 登录认证概念

1. 身份验证
   * 一般需要提供标志信息来表明登录者的身份
   * 比如 email 、 用户名/密码 

2. principals / credentials
   * principals: `/ˈprɪnsəpəlz/` , 身份
   * credentials: `/krəˈdenʃlz/`, 证明
   * 在 Shiro 中，用户需要提供 身份/证明 来验证用户身份

3. principals
   * 身份，即主体的标识属性
   * 比如: 用户名、邮箱、手机号（唯一即可）
   * 但只有一个 primary principals

4. credentials
   * 证明 / 凭证
   * 只有主体知道的安全值
   * 比如: 密码 、数字证书

5. 最常见的 principals/credentials 组合就是 用户名/密码

#### 2.3.2. 登录认证基本流程

1. 收集用户 身份/凭证，比如 用户名/密码
2. 调用 Subject.login() 登录
   * 登录失败则抛异常 AuthenticationException
3. 创建自定义 Realm 类
   * 继承 AuthenticatingRealm 类
   * 实现 doGetAuthenticationInfo() 方法

![image-20250827220604792](./images/image-20250827220604792.png)

#### 2.3.3. 登录认证实例

```java
// 1. 初始化: 创建 securityManager
IniSecurityManagerFactory securityManagerFactory = new IniSecurityManagerFactory("classpath:shiro.ini");
SecurityManager securityManager = securityManagerFactory.getInstance();
// securityManager 放入 SecurityUtils
SecurityUtils.setSecurityManager(securityManager);

// 2. 获取 Subject 对象
Subject subject = SecurityUtils.getSubject();

// 3. 创建 token 对象
AuthenticationToken token = new UsernamePasswordToken("zhangsan", "123");

try {
    // 4. 登录
    subject.login(token);

    System.out.println("登录成功");
} catch (UnknownAccountException e) {
    System.out.println("登录失败: 用户名不存在");
} catch (IncorrectCredentialsException e) {
    System.out.println("登录失败: 密码错误");
} catch (AuthenticationException e) {
    System.out.println("登录失败: 未知错误");
}
```

### 2.4. 角色 和 授权

#### 2.4.1. 授权概念

1. 授权
   * 访问控制，即在应用中控制谁能访问的哪些资源
   * 关键对象：主体(subject)、资源(resource)、权限(Permission)、角色(role)

2. 主体(subject)
   * 访问应用的用户
   * 在 shiro 中，Subject 代表该用户
   * 用户只有授权后才允许访问相应资源

3. 资源(resource)
   * 用户可以访问的 URL

4. 权限(permission)
   * 在应用中用户能不能访问某个资源

5. 角色(role)
   * 权限的集合
   * 一般会赋予用户角色，不同的角色拥有一组不同的权限

#### 2.4.2. 授权方式

编程:

```java
if (subject.hasRole("admin")) {
    // 有权限
} else {
    // 无权限
}
```

注解:

```java
// 在方法上放置相应注解，没有权限则抛出相应异常
@RequiresRoles("admin")
@PostMapping("/user/getById")
public JsonResult getById(String id) {
    // 有权限
}
```

#### 2.4.3. 授权流程

1. 先调用 `subject.hasRole()` / `subject.isPermitted()`
   * 委托给 SecurityManager
   * SecurityManager 委托给 Authorizer

2. Authorizer 是真正的授权者
   * 比如调用 `subject.isPermitted("user:insert")`
   * PermissionResolver 把 `"user:insert"` 转为相应 Permission 实例

3. 在授权前，会调用相应的 Realm 获取 subject 的 角色和权限

4. Authorizer 会判断 Realm 的 角色/权限 是否与传入的匹配

#### 2.4.4. 授权实例

shiro.ini :

```ini
[users]
zhangsan=123,role1,role2
lisi=456

[roles]
role1=user:insert,user:select
```

代码:

```java
try {
    // 4. 登录
    subject.login(token);
    System.out.println("登录成功");
} catch (UnknownAccountException e) {
    System.out.println("登录失败: 用户名不存在");
} catch (IncorrectCredentialsException e) {
    System.out.println("登录失败: 密码错误");
} catch (AuthenticationException e) {
    System.out.println("登录失败: 未知错误");
}

// 5. 判断角色: 用户 是否 有指定的角色
boolean hasRole1 = subject.hasRole("role1");
System.out.println("hasRole1 = " + hasRole1);

// 6. 判断权限: 用户 是否 有指定的权限
boolean isPermittedOfUserInsert = subject.isPermitted("user:insert");
System.out.println("isPermittedOfUserInsert = " + isPermittedOfUserInsert);

// 检查权限，没有则抛异常(UnauthorizedException)
subject.checkPermission("user:insert2");
```

### 2.5. MD5 加密

使用 Shiro 的加密工具类，实现方便的加密

```java
String password = "123456";

// md5 加密
Md5Hash md5Hash1 = new Md5Hash(password);
System.out.println("md5Hash1 = \t" + md5Hash1.toHex());

// md5 带盐加密
Md5Hash md5Hash2 = new Md5Hash(password, "salt-test");
System.out.println("md5Hash2 = \t" + md5Hash2.toHex());

// md5 带盐 迭代 加密
Md5Hash md5Hash3 = new Md5Hash(password, "salt-test", 3);
System.out.println("md5Hash3 = \t" + md5Hash3.toHex());

// (使用 Md5Hash 的父类) md5 带盐 迭代 加密
SimpleHash md5Hash4 = new SimpleHash("MD5", password, "salt-test", 3);
System.out.println("md5Hash4 = \t" + md5Hash4.toHex());
```

## 3. 与 Spring Boot 整合