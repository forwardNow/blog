<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2025-12-04 18:10:30
@modify date 2025-12-06 17:18:57
@desc [description]
#endregion-->

# MybatisPlus教程-黑马

官网: https://www.baomidou.com/

教程文档: https://ai.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc

目录:

* 快速入门
* 核心功能
* 扩展功能
* 插件功能

## 1. 快速入门

目录:

* 入门案例
   * 学会 MP 的基本用法
   * 体会 MP 的无侵入和方便快捷的特点
* 常见注解
* 常见配置

### 1.1. 入门案例

使用 MybatisPlus 的基本步骤:

1. 引入 MybatisPlus 依赖，代替 Mybatis 依赖
2. 定义 Mapper 接口并继承 BaseMapper

#### 1.1.1. 引入依赖

MyBatisPlus 官方提供了 starter，其中集成了 Mybatis 和 MybatisPlus 的所有功能，并且实现了自动装配效果。

因此我们可以用MybatisPlus的starter代替Mybatis的starter：

```xml
<!--
<dependency>
   <groupId>org.mybatis.spring.boot</groupId>
   <artifactId>mybatis-spring-boot-starter</artifactId>
   <version>2.3.1</version>
</dependency>
-->
<dependency>
   <groupId>com.baomidou</groupId>
   <artifactId>mybatis-plus-boot-starter</artifactId>
   <version>3.5.3.1</version>
</dependency>
```

#### 1.1.2. 定义 Mapper 接口

自定义的 Mapper 继承 MybatisPlus 提供的 BaseMapper 接口：

```java
public interface UserMapper extends BaseMapper<User> {
   
}
/*
继承 BaseMapper 后，就有如下 增删改查方法:
   
   int insert(T entity);

   int deleteById(Serializable id);
   int deleteById(T entity);
   int deleteByMap(Map<String, Object> columnMap);
   int delete(Wrapper<T> queryWrapper);
   int deleteBatchIds(Collection<?> idList);

   int updateById(T entity);
   int update(T entity, Wrapper<T> updateWrapper);

   T selectById(Serializable id);
   List<T> selectBatchIds(Collection<? extends Serializable> idList);
   List<T> selectByMap(Map<String, Object> columnMap);
   T selectOne(Wrapper<T> queryWrapper)
   boolean exists(Wrapper<T> queryWrapper)

   Long selectCount(Wrapper<T> queryWrapper);
   List<T> selectList(Wrapper<T> queryWrapper);
   List<Map<String, Object>> selectMaps(Wrapper<T> queryWrapper);
   List<Object> selectObjs(Wrapper<T> queryWrapper);
   <P extends IPage<T>> P selectPage(P page, Wrapper<T> queryWrapper);
   <P extends IPage<Map<String, Object>>> P selectMapsPage(P page, Wrapper<T> queryWrapper);
*/
```

### 1.2. 常见注解

#### 1.2.1. 原理

MyBatisPlus 通过扫描实体类，并基于反射获取实体类信息作为数据库表信息。

1.根据 `BaseMapper<User>` 中的 `User` 实体类信息

```java
public interface UserMapper extends BaseMapper<User> { }

@Data
public class User {
    private Long id;
    private String username;
    private String password;
    private String phone;
    private String info;
    private Integer status;
    private Integer balance;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
}
```

2.解析实体类获取表信息

* 表名: 类名 驼峰转下划线
* 主键: 名为 id 的成员变量
* 字段名: 成员变量名 驼峰转下划线

以上是按约定来，如果不按约定来则需要显式设置

#### 1.2.2. 基础注解

MybatisPlus 中比较常用的几个注解如下：

* `@TableName` : 指定表名
* `@TableId` : 指定表中的主键字段信息
* `@TableField` : 指定表中的普通字段信息


`@TableName`:

* 当 类名转下划线 后，与数据库表名不一致，则需要显式设置


`@TableId`:

* 设置主键字段及类型(`type`)
* 类型的值为 IdType 枚举类型
* `IdType.AUTO` : 数据库自增长
* `IdType.INPUT` : 通过set方法自行输入
* `IdType.ASSIGN_ID` : 默认。分配 ID，接口 IdentifierGenerator 的方法 nextId 来生成 id，默认实现类为 DefaultIdentifierGenerator 雪花算法


`@TableField`:

* 成员变量名与数据库字段名不一致
* 成员变量名以 `is` 开头，且是布尔值。(反射时通常会去掉 `is`)
   * MySQL不原生支持布尔类型，但 `bit(1)` 或‌ `TINYINT(1)` 常作为替代方案
   * `bit(1)` 更直接映射二进制逻辑，而 `TINYINT(1)` 兼容性更广
   * `bit` 类型存储二进制值，每个位只能是 0 或 1，基础长度为 1 位，默认长度为 1。‌‌
* 成员变量名与数据库关键字冲突。（需要转义）
* 成员变量不是数据库字段

示例:

```java
@TableName("tb_user")
public class User {
   @TableId(value="id", type=IdType.AUTO)
   private Long id;

   @TableField("username")
   private String name;

   @TableField("is_married")
   private Boolean isMarried; // 对应的数据库字段类型 bit(1)

   @TableField("`order`")
   private Integer order;

   @TableField(exist = false)
   private String address;
}
```

#### 1.2.3. 总结

MybatisPlus 是如何获取实现CRUD的数据库表信息的？

* 默认以类名驼峰转下划线作为表名
* 默认把名为id的字段作为主键
* 默认把变量名驼峰转下划线作为表的字段名


MybatisPlus 的常用注解有哪些？

* @TableName：指定表名称及全局配置
* @TableId：指定id字段及相关配置
* @TableField：指定普通字段及相关配置


IdType的常见类型有哪些？

* AUTO 
* ASSIGN_ID
* INPUT


使用 @TableField 的常见场景是？

* 成员变量名与数据库字段名不一致
* 成员变量名以is开头，且是布尔值
* 成员变量名与数据库关键字冲突
* 成员变量不是数据库字段

### 1.3. 常见配置

MyBatisPlus 的配置项继承了 MyBatis 原生配置和一些自己特有的配置。例如：

```yml
mybatis-plus:
  # 别名扫描包  
  # 在 mapper.xml 文件中使用实体类时，可以省略全路径
  type-aliases-package: com.itheima.mp.domain.po 

  # Mapper.xml文件地址，默认值
  # MP 擅长单表增删改查，复杂 SQL 语句还是要在 mapper.xml 文件中写
  mapper-locations: "classpath*:/mapper/**/*.xml" 
  
  configuration:    
    # 是否开启下划线和驼峰的映射    
    map-underscore-to-camel-case: true 
  
    # 是否开启二级缓存
    # 一般不开启
    cache-enabled: false 
  
  global-config:    
    db-config:      
      # id 为雪花算法生成      
      id-type: assign_id 
      # 更新策略：只更新非空字段
      update-strategy: not_null 
```

配置文档: https://www.baomidou.com/reference/

### 1.4. 总结

MyBatisPlus使用的基本流程是什么？

* 引入起步依赖
* 自定义 Mapper 基础 BaseMapper
* 在实体类上添加注解声明 表信息
* 在 application.yml 中根据需要添加配置

## 2. 核心功能

目录:

* 条件构造器
* 自定义 SQL
* Service 接口

### 2.1. 条件构造器

#### 2.1.1. 介绍

MyBatisPlus 支持各种复杂的 where 条件，可以满足日常开发的所有需求。

`Wrapper` 类的继承结构（部分）:

```text
Wrapper
  AbstractWrapper
    QueryWrapper
    UpdateWrapper
    AbstractLambdaWrapper
      LambdaUpdateWrapper
      LambdaQueryWrapper
```

`AbstractWrapper` 里存在各种构造条件方法: (构造 where 语句)

```java
allEq(boolean condition, Map<R, V> params, boolean null2IsNull)

eq(boolean condition, R column, Object val)
ne(boolean condition, R column, Object val)
gt(boolean condition, R column, Object val)
ge(boolean condition, R column, Object val)
lt(boolean condition, R column, Object val)
le(boolean condition, R column, Object val)
like(boolean condition, R column, Object val)
likeLeft(boolean condition, R column, Object val)
likeRight(boolean condition, R column, Object val)
notLike(boolean condition, R column, Object val)
notLikeLeft(boolean condition, R column, Object val)
notLikeRight(boolean condition, R column, Object val)

// ......
```

`QueryWrapper` 查询相关的方法: (构造 SELECT 语句)

```java
// SELECT 语句

// 比如: SELECT id,username,info,balance 
select(String... columns)
select(List<String> columns)
select(Class<T> entityClass, Predicate<TableFieldInfo> predicate)
```

`UpdateWrapper` 更新相关的方法: (构造 SET 语句)

```java
// SET 语句

// 比如: SET balance = balance - 200    
setSql(boolean condition, String sql)
```

AbstractLambdaWrapper/LambdaUpdateWrapper/LambdaQueryWrapper 

* 基于 lambda 语法。推荐使用
* 使用方式与 非lambda 一致，可以避免硬编码
* `QueryWrapper.lambda()` 返回 `LambdaQueryWrapper`
* `UpdateWrapper.lambda()` 返回 `LambdaUpdateWrapper`

#### 2.1.2. 案例: 基于 QueryWrapper 的查询

需求1: 查询出名字中带 `o` 的，存款大于等于 1000 元的人的 id、username、info、balance 字段:

```java
/*
SELECT id,username,info,balance 
FROM user 
WHERE username LIKE ? AND balance >= ?
*/

// 1. 构造查询条件
QueryWrapper<User> wrapper = new QueryWrapper<User>()
        .select("id","username","info","balance" )
        .like("username", "o")
        .ge("balance", 1000);

// lambda 方式避免硬编码
LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<User>()
        .select(User::getId,User::getUsername,User::getInfo,User::getBalance )
        .like(User::getUsername, "o")
        .ge(User::getBalance, 1000);

// 2. 查询
List<User> users = userMapper.selectList(wrapper);

users.forEach(System.out::println);
```

需求2: 更新用户名为 jack 的用户的余额为 2000

```java
/*
UPDATE user     
SET balance = 2000     
WHERE (username = "jack")
*/

// 1. 要更新的数据
User user = new User();
user.setBalance(2000);

// 2. 更新的条件
QueryWrapper<User> wrapper = new QueryWrapper<User>()
        .eq("username", "jack");

// 3. 执行更新
int updateCount = userMapper.update(user, wrapper);

System.out.println("updateCount = " + updateCount); //=> 1
```

需求3: 更新 id 为 1,2,4 的用户的余额，扣 200

```java
/*
UPDATE user     
SET balance = balance - 200     
WHERE id in (1, 2, 4)
*/

List<Long> ids = List.of(1L, 2L, 4L);

UpdateWrapper<User> wrapper = new UpdateWrapper<User>()
        .setSql("balance = balance - 200   ")
        .in("id", ids);

int updateCount = userMapper.update(null, wrapper);

System.out.println("updateCount = " + updateCount); //=> 3
```

#### 2.1.3. 总结

条件构造器的用法：

* `QueryWrapper` 和 `LambdaQueryWrapper` 通常用来构建 select、delete、update 的 where 条件部分
* `UpdateWrapper` 和 `LambdaUpdateWrapper` 通常只有在 set 语句比较特殊才使用
* 尽量使用 `LambdaQueryWrapper` 和 `LambdaUpdateWrapper` ，避免硬编码

### 2.2. 自定义 SQL

#### 2.2.1. 介绍

利用 MyBatisPlus 的 Wrapper 来构建复杂的 Where 条件，然后自己定义 SQL 语句中剩下的部分。

需求：将 id 在指定范围的用户（例如 1、2、4 ）的余额扣减指定值

```xml
<!-- 直接在 mapper.xml 文件中写，WHERE 相对来说很繁琐 -->
<update id="updateBalanceByIds">    
  UPDATE user     
  SET balance = balance - #{amount}    
  WHERE id IN    
    <foreach collection="ids" separator="," item="id" open="(" close=")">        
    #{id}    
    </foreach>
</update>
```

```java
// setSql() 直接在 业务层写 SQL 语句，违反开发规范

List<Long> ids = List.of(1L, 2L, 4L);
UpdateWrapper<User> wrapper = new UpdateWrapper<User>()
        .setSql("balance = balance - 200   ")
        .in("id", ids);
int updateCount = userMapper.update(null, wrapper);
```

```xml
<!-- 这种复杂的 SELECT 子句如果通过 MP 的 select() 直接写 SQL 就会违反开发规范 -->
<update id="selectXxx">
  SELECT status, COUNT(id) AS total
  FROM tb_user
  <where>    
    <if test="name != null">AND username LIKE #{name}</if>    
    <if test="ids != null">        
      AND id IN        
        <foreach collection="ids" open="(" close=")" item="id" separator=",">            
          #{id}        
        </foreach>    
    </if>
  </where>
  GROUP BY status
</update>
```

#### 2.2.2. 步骤

步骤1: 基于 Wrapper 构建 WHERE 条件

```java
List<Long> ids = List.of(1L, 2L, 4L);
int amount = 200;

// 1.构建条件
LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<User>().in(User::getId, ids);

// 2.自定义 SQL 方法调用
userMapper.updateBalanceByIds(wrapper, amount);

/*
==>  Preparing: UPDATE user SET balance = balance - ? WHERE (id IN (?,?,?))
==> Parameters: 200(Integer), 1(Long), 2(Long), 4(Long)
<==    Updates: 3
  */
```

步骤2: 在 mapper 方法参数中用 `@Param("ew")` 声明 wrapper 变量名称

```java
public interface UserMapper extends BaseMapper<User> {
    // 建议使用 @Param(Constants.WRAPPER) 替代 @Param("ew")  
    // com.baomidou.mybatisplus.core.toolkit.Constants.Constants.WRAPPER = "ew"
    void updateBalanceByIds(@Param("ew") LambdaQueryWrapper<User> wrapper, @Param("amount") int amount);
}
```

步骤3: 自定义SQL，并使用 Wrapper 条件

```xml
<update id="updateBalanceByIds">
    UPDATE user
    SET balance = balance - #{amount}
    <!-- 下面就是 wrapper 构造的 WHERE 子句 -->
    ${ew.customSqlSegment}
</update>
```

### 2.3. IService 基本用法

#### 2.3.1. 介绍

增:

```java
save(T entity): boolean
saveBatch(Collection<T> entityList)   : boolean
saveBatch(Collection<T> entityList)   : boolean
```

删:

```java
remove(Wrapper<T> queryWrapper)                   : boolean

removeById(Serializable id)                       : boolean
removeById(Serializable id, boolean useFill)      : boolean
removeById(T entity)                              : boolean

removeByMap(Map<String, Object> columnMap)        : boolean

// 单个 DELETE 语句，where id in (?,?,?)，适合一千个以内
removeByIds(Collection<?> list)                   : boolean
removeByIds(Collection<?> list, boolean useFill)  : boolean

// 多个 DELETE 语句，批处理，数据量大时 效率高
removeBatchByIds(Collection<?> list)    : boolean
removeBatchByIds(Collection<?> list, boolean useFill) : boolean
removeBatchByIds(Collection<?> list, int batchSize)   : boolean
removeBatchByIds(Collection<?> list, int batchSize, boolean useFill)  : boolean
```

改:

```java
update(Wrapper<T> updateWrapper)            : boolean
update(T entity, Wrapper<T> updateWrapper)  : boolean

updateById(T entity)    : boolean

updateBatchById(Collection<T> entityList)                 : boolean
updateBatchById(Collection<T> entityList, int batchSize)  : boolean
```

增或改:(无 ID 则 INSERT，有 ID 则 UPDATE)

```java
saveOrUpdate(T entity)                          : boolean
saveOrUpdate(T entity, Wrapper<T> updateWrapper): boolean

saveOrUpdateBatch(Collection<T> entityList)                 : boolean
saveOrUpdateBatch(Collection<T> entityList, int batchSize)  : boolean
```

查(单个):

```java
getById(Serializable id)                          : T

getOne(Wrapper<T> queryWrapper)                   : T
getOne(Wrapper<T> queryWrapper, boolean throwEx)  : T
```

查(列表):

```java
// 无参，查所有
list()                            : List<T>
list(Wrapper<T> queryWrapper)     : List<T>

listByIds(Collection<? extends Serializable> idList)  : List<T>
listByMap(Map<String, Object> columnMap)              : List<T>

listMaps()                        : List<Map<String, Object>>
listMaps(Wrapper<T> queryWrapper) : List<Map<String, Object>>

listObjs()                        : List<Object>
listObjs(Wrapper<T> queryWrapper) : List<Object>
listObjs(Function<? super Object, V> mapper)                          : List<V>
listObjs(Wrapper<T> queryWrapper, Function<? super Object, V> mapper) : List<V>
```

查(分页):

```java
page(E page)                          : E
page(E page, Wrapper<T> queryWrapper) : E

pageMaps(E page)                          : E
pageMaps(E page, Wrapper<T> queryWrapper) : E
```

查(总数):

```java
count()                         : long
count(Wrapper<T> queryWrapper)  : long
```

Lambda:（查询或更新 时构造复杂条件）

```java
lambdaQuery()         : LambdaQueryChainWrapper<T>
lambdaQuery(T entity) : LambdaQueryChainWrapper<T>
lambdaUpdate()        : LambdaUpdateChainWrapper<T>
```

#### 2.3.2. 使用

步骤1: 自定义接口继承 `IService<实体类>`

```java
public interface IUserService extends IService<User> {
}
```

步骤2: 自定义接口的实现类 继承 `IService` 的实现类(`ServiceImpl<Mapper,实体类>`)

```java
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {
}

public interface UserMapper extends BaseMapper<User> {
}
```

测试:

```java
@SpringBootTest
class UserServiceImplTest {
    @Autowired
    private IUserService userService;

    @Test
    void testList() {
        List<User> list = userService.list();
        list.forEach(System.out::println);
    }
}
```

#### 2.3.3. 总结

MP 的 Service 接口使用流程是怎样的？

1.自定义 Service 接口继承 IService 接口

```java
public interface IUserService extends IService<User> {}
```

2.自定义 Service 实现类，实现自定义接口并继承 ServiceImpl 类

```java
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {}
```

### 2.4. IService 开发基础业务接口

>`BaseMapper<User>` 和 `IService<User>` 中的很多方法功能是一致的，实际业务开发时到底使用哪个？

需求：基于 Restful 风格实现下面的接口

| 编号 | 接口 | 请求方式 | 请求路径 | 请求参数 | 返回值 |
| - | - | - | - | - | - |
| 1 | 新增用户 | POST | /users | 用户表单实体DTO | 无 |
| 2 | 删除用户 | DELETE | /users/{id} | 用户ID | 无 |
| 3 | 根据id查询用户 | GET | /users/{id} | 用户ID | 用户VO |
| 4 | 根据id批量查询 | GET | /users | 用户ID集合 | 用户VO集合 |
| 5 | 根据id扣减余额 | PUT | /users/{id}/deduction/{money} | 用户ID/扣减金额 | 无 |

说明:

* PO: Persistent Object, 持久化对象, 如 User
* DTO: Data Transfer Object, 数据传输对象; 控制层 接收参数使用 
* VO: View Object, 控制层; 返回结果使用 

引入依赖: (web 和 swagger)

```xml
<!--swagger-->
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-openapi2-spring-boot-starter</artifactId>
    <version>4.1.0</version>
</dependency>
<!--web-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

配置:(swagger)

```yml
knife4j:
  enable: true
  openapi:
    title: 用户管理接口文档
    description: "用户管理接口文档"
    email: zhanghuyi@itcast.cn
    concat: 虎哥
    url: https://www.itcast.cn
    version: v1.0.0
    group:
      default:
        group-name: default
        api-rule: package
        api-rule-resources:
          - com.itheima.mp.controller
```

接口需要两个实体：

* UserFormDTO：代表新增时的用户表单
* UserVO：代表查询的返回结果

```java
@Data
@ApiModel(description = "用户表单实体")
public class UserFormDTO {

    @ApiModelProperty("id")
    private Long id;

    @ApiModelProperty("用户名")
    private String username;

    @ApiModelProperty("密码")
    private String password;

    @ApiModelProperty("注册手机号")
    private String phone;

    @ApiModelProperty("详细信息，JSON风格")
    private String info;

    @ApiModelProperty("账户余额")
    private Integer balance;
}


@Data
@ApiModel(description = "用户VO实体")
public class UserVO {
    
    @ApiModelProperty("用户id")
    private Long id;
    
    @ApiModelProperty("用户名")
    private String username;
    
    @ApiModelProperty("详细信息")
    private String info;

    @ApiModelProperty("使用状态（1正常 2冻结）")
    private Integer status;
    
    @ApiModelProperty("账户余额")
    private Integer balance;
}
```

按照 Restful 风格编写 Controller 接口方法:

```java
@Api(tags = "用户管理接口")
@RequestMapping("users")
@RestController
// 针对加了 final 的成员变量，会添加到构造函数的形参中，进而会被 spring 注入依赖
@RequiredArgsConstructor
public class UserController {

    private final IUserService userService;

    @ApiOperation("新增用户")
    @PostMapping
    public void saveUser(@RequestBody UserFormDTO userFormDTO){
        // 1.转换DTO为PO
        User user = BeanUtil.copyProperties(userFormDTO, User.class);
        // 2.新增
        userService.save(user);
    }

    @ApiOperation("删除用户")
    @DeleteMapping("/{id}")
    public void removeUserById(@ApiParam("用户id") @PathVariable("id") Long userId){
        userService.removeById(userId);
    }

    @ApiOperation("根据id查询用户")
    @GetMapping("/{id}")
    public UserVO queryUserById(@ApiParam("用户id") @PathVariable("id") Long userId){
        // 1.查询用户
        User user = userService.getById(userId);
        // 2.处理vo
        return BeanUtil.copyProperties(user, UserVO.class);
    }

    @ApiOperation("根据id集合查询用户")
    @GetMapping
    public List<UserVO> queryUserByIds(@ApiParam("用户id集合") @RequestParam("ids") List<Long> ids){
        // 1.查询用户
        List<User> users = userService.listByIds(ids);
        // 2.处理vo
        return BeanUtil.copyToList(users, UserVO.class);
    }
}
```

可以看到上述接口都直接在 controller 即可实现，无需编写任何 service 代码，非常方便。

### 2.5. IService 开发复杂业务接口

说明:

* 在 UserServiceImpl 中已经自动注入了 `UserMapper` (`baseMapper`), 通过 this.baseMapper 可以直接调用 `UserMapper` 的方法

示例:

```java
@RequestMapping("users")
@RestController
@RequiredArgsConstructor
public class UserController {
    private final IUserService userService;

    @PutMapping("/{id}/deduction/{money}")
    public void deductionBalance( @PathVariable("id") Long userId, @PathVariable("money") Integer money){
        userService.deductionBalance(userId, money);
    }
}


public interface IUserService extends IService<User> {
    void deductionBalance(Long userId, Integer money);
}


@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {
    @Override
    public void deductionBalance(Long id, Integer money) {
        // 1. 查询用户
        User user = this.getById(id);

        // 2. 校验用户状态
        if (user == null || user.getStatus() == 2) {
            throw new RuntimeException("用户状态异常！");
        }

        // 3. 校验余额是否充足
        Integer balance = user.getBalance();
        if (balance < money) {
            throw new RuntimeException("用户余额不足！");
        }

        // 4. 扣减余额
        // this.baseMapper 指向 UserMapper
        this.baseMapper.deductionBalance(id, money);
    }
}


public interface UserMapper extends BaseMapper<User> {
    @Update("UPDATE user SET balance = balance - #{money} WHERE id = #{id}")
    void deductionBalance(@Param("id") Long id, @Param("money") Integer money);
}
```
