<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2025-12-04 18:10:30
@modify date 2025-12-05 21:52:28
@desc [description]
#endregion-->

# MybatisPlus教程-黑马

官网: https://www.baomidou.com/

目录:

* 快速入门
* 核心功能
* 扩展功能
* 插件功能

## 1. 快速入门

目录:

* 入门案例
   * 学会 MP 的基本用法
   * 体会 MP 的无侵入和方便快捷的特点
* 常见注解
* 常见配置

### 1.1. 入门案例

使用 MybatisPlus 的基本步骤:

1. 引入 MybatisPlus 依赖，代替 Mybatis 依赖
2. 定义 Mapper 接口并继承 BaseMapper

#### 1.1.1. 引入依赖

MyBatisPlus 官方提供了 starter，其中集成了 Mybatis 和 MybatisPlus 的所有功能，并且实现了自动装配效果。

因此我们可以用MybatisPlus的starter代替Mybatis的starter：

```xml
<!--
<dependency>
   <groupId>org.mybatis.spring.boot</groupId>
   <artifactId>mybatis-spring-boot-starter</artifactId>
   <version>2.3.1</version>
</dependency>
-->
<dependency>
   <groupId>com.baomidou</groupId>
   <artifactId>mybatis-plus-boot-starter</artifactId>
   <version>3.5.3.1</version>
</dependency>
```

#### 1.1.2. 定义 Mapper 接口

自定义的 Mapper 继承 MybatisPlus 提供的 BaseMapper 接口：

```java
public interface UserMapper extends BaseMapper<User> {
   
}
/*
继承 BaseMapper 后，就有如下 增删改查方法:
   
   int insert(T entity);

   int deleteById(Serializable id);
   int deleteById(T entity);
   int deleteByMap(Map<String, Object> columnMap);
   int delete(Wrapper<T> queryWrapper);
   int deleteBatchIds(Collection<?> idList);

   int updateById(T entity);
   int update(T entity, Wrapper<T> updateWrapper);

   T selectById(Serializable id);
   List<T> selectBatchIds(Collection<? extends Serializable> idList);
   List<T> selectByMap(Map<String, Object> columnMap);
   T selectOne(Wrapper<T> queryWrapper)
   boolean exists(Wrapper<T> queryWrapper)

   Long selectCount(Wrapper<T> queryWrapper);
   List<T> selectList(Wrapper<T> queryWrapper);
   List<Map<String, Object>> selectMaps(Wrapper<T> queryWrapper);
   List<Object> selectObjs(Wrapper<T> queryWrapper);
   <P extends IPage<T>> P selectPage(P page, Wrapper<T> queryWrapper);
   <P extends IPage<Map<String, Object>>> P selectMapsPage(P page, Wrapper<T> queryWrapper);
*/
```

### 1.2. 常见注解

#### 1.2.1. 原理

MyBatisPlus 通过扫描实体类，并基于反射获取实体类信息作为数据库表信息。

1.根据 `BaseMapper<User>` 中的 `User` 实体类信息

```java
public interface UserMapper extends BaseMapper<User> { }

@Data
public class User {
    private Long id;
    private String username;
    private String password;
    private String phone;
    private String info;
    private Integer status;
    private Integer balance;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
}
```

2.解析实体类获取表信息

* 表名: 类名 驼峰转下划线
* 主键: 名为 id 的成员变量
* 字段名: 成员变量名 驼峰转下划线

以上是按约定来，如果不按约定来则需要显式设置

#### 1.2.2. 基础注解

MybatisPlus 中比较常用的几个注解如下：

* `@TableName` : 指定表名
* `@TableId` : 指定表中的主键字段信息
* `@TableField` : 指定表中的普通字段信息


`@TableName`:

* 当 类名转下划线 后，与数据库表名不一致，则需要显式设置


`@TableId`:

* 设置主键字段及类型(`type`)
* 类型的值为 IdType 枚举类型
* `IdType.AUTO` : 数据库自增长
* `IdType.INPUT` : 通过set方法自行输入
* `IdType.ASSIGN_ID` : 默认。分配 ID，接口 IdentifierGenerator 的方法 nextId 来生成 id，默认实现类为 DefaultIdentifierGenerator 雪花算法


`@TableField`:

* 成员变量名与数据库字段名不一致
* 成员变量名以 `is` 开头，且是布尔值。(反射时通常会去掉 `is`)
   * MySQL不原生支持布尔类型，但 `bit(1)` 或‌ `TINYINT(1)` 常作为替代方案
   * `bit(1)` 更直接映射二进制逻辑，而 `TINYINT(1)` 兼容性更广
   * `bit` 类型存储二进制值，每个位只能是 0 或 1，基础长度为 1 位，默认长度为 1。‌‌
* 成员变量名与数据库关键字冲突。（需要转义）
* 成员变量不是数据库字段

示例:

```java
@TableName("tb_user")
public class User {
   @TableId(value="id", type=IdType.AUTO)
   private Long id;

   @TableField("username")
   private String name;

   @TableField("is_married")
   private Boolean isMarried; // 对应的数据库字段类型 bit(1)

   @TableField("`order`")
   private Integer order;

   @TableField(exist = false)
   private String address;
}
```

#### 1.2.3. 总结

MybatisPlus 是如何获取实现CRUD的数据库表信息的？

* 默认以类名驼峰转下划线作为表名
* 默认把名为id的字段作为主键
* 默认把变量名驼峰转下划线作为表的字段名


MybatisPlus 的常用注解有哪些？

* @TableName：指定表名称及全局配置
* @TableId：指定id字段及相关配置
* @TableField：指定普通字段及相关配置


IdType的常见类型有哪些？

* AUTO 
* ASSIGN_ID
* INPUT


使用 @TableField 的常见场景是？

* 成员变量名与数据库字段名不一致
* 成员变量名以is开头，且是布尔值
* 成员变量名与数据库关键字冲突
* 成员变量不是数据库字段

### 1.3. 常见配置

MyBatisPlus 的配置项继承了 MyBatis 原生配置和一些自己特有的配置。例如：

```yml
mybatis-plus:
  # 别名扫描包  
  # 在 mapper.xml 文件中使用实体类时，可以省略全路径
  type-aliases-package: com.itheima.mp.domain.po 

  # Mapper.xml文件地址，默认值
  # MP 擅长单表增删改查，复杂 SQL 语句还是要在 mapper.xml 文件中写
  mapper-locations: "classpath*:/mapper/**/*.xml" 
  
  configuration:    
    # 是否开启下划线和驼峰的映射    
    map-underscore-to-camel-case: true 
  
    # 是否开启二级缓存
    # 一般不开启
    cache-enabled: false 
  
  global-config:    
    db-config:      
      # id 为雪花算法生成      
      id-type: assign_id 
      # 更新策略：只更新非空字段
      update-strategy: not_null 
```

配置文档: https://www.baomidou.com/reference/

### 1.4. 总结

MyBatisPlus使用的基本流程是什么？

* 引入起步依赖
* 自定义 Mapper 基础 BaseMapper
* 在实体类上添加注解声明 表信息
* 在 application.yml 中根据需要添加配置

## 2. 核心功能

目录:

* 条件构造器
* 自定义 SQL
* Service 接口

### 2.1. 条件构造器

#### 2.1.1. 介绍

MyBatisPlus 支持各种复杂的 where 条件，可以满足日常开发的所有需求。

`Wrapper` 类的继承结构（部分）:

```text
Wrapper
  AbstractWrapper
    QueryWrapper
    UpdateWrapper
    AbstractLambdaWrapper
      LambdaUpdateWrapper
      LambdaQueryWrapper
```

`AbstractWrapper` 里存在各种构造条件方法: (构造 where 语句)

```java
allEq(boolean condition, Map<R, V> params, boolean null2IsNull)

eq(boolean condition, R column, Object val)
ne(boolean condition, R column, Object val)
gt(boolean condition, R column, Object val)
ge(boolean condition, R column, Object val)
lt(boolean condition, R column, Object val)
le(boolean condition, R column, Object val)
like(boolean condition, R column, Object val)
likeLeft(boolean condition, R column, Object val)
likeRight(boolean condition, R column, Object val)
notLike(boolean condition, R column, Object val)
notLikeLeft(boolean condition, R column, Object val)
notLikeRight(boolean condition, R column, Object val)

// ......
```

`QueryWrapper` 查询相关的方法: (构造 SELECT 语句)

```java
// SELECT 语句

// 比如: SELECT id,username,info,balance 
select(String... columns)
select(List<String> columns)
select(Class<T> entityClass, Predicate<TableFieldInfo> predicate)
```

`UpdateWrapper` 更新相关的方法: (构造 SET 语句)

```java
// SET 语句

// 比如: SET balance = balance - 200    
setSql(boolean condition, String sql)
```

AbstractLambdaWrapper/LambdaUpdateWrapper/LambdaQueryWrapper 

* 基于 lambda 语法。推荐使用
* 使用方式与 非lambda 一致，可以避免硬编码
* `QueryWrapper.lambda()` 返回 `LambdaQueryWrapper`
* `UpdateWrapper.lambda()` 返回 `LambdaUpdateWrapper`

#### 2.1.2. 案例: 基于 QueryWrapper 的查询

需求1: 查询出名字中带 `o` 的，存款大于等于 1000 元的人的 id、username、info、balance 字段:

```java
/*
SELECT id,username,info,balance 
FROM user 
WHERE username LIKE ? AND balance >= ?
*/

// 1. 构造查询条件
QueryWrapper<User> wrapper = new QueryWrapper<User>()
        .select("id","username","info","balance" )
        .like("username", "o")
        .ge("balance", 1000);

// lambda 方式避免硬编码
LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<User>()
        .select(User::getId,User::getUsername,User::getInfo,User::getBalance )
        .like(User::getUsername, "o")
        .ge(User::getBalance, 1000);

// 2. 查询
List<User> users = userMapper.selectList(wrapper);

users.forEach(System.out::println);
```

需求2: 更新用户名为 jack 的用户的余额为 2000

```java
/*
UPDATE user     
SET balance = 2000     
WHERE (username = "jack")
*/

// 1. 要更新的数据
User user = new User();
user.setBalance(2000);

// 2. 更新的条件
QueryWrapper<User> wrapper = new QueryWrapper<User>()
        .eq("username", "jack");

// 3. 执行更新
int updateCount = userMapper.update(user, wrapper);

System.out.println("updateCount = " + updateCount); //=> 1
```

需求3: 更新 id 为 1,2,4 的用户的余额，扣 200

```java
/*
UPDATE user     
SET balance = balance - 200     
WHERE id in (1, 2, 4)
*/

List<Long> ids = List.of(1L, 2L, 4L);

UpdateWrapper<User> wrapper = new UpdateWrapper<User>()
        .setSql("balance = balance - 200   ")
        .in("id", ids);

int updateCount = userMapper.update(null, wrapper);

System.out.println("updateCount = " + updateCount); //=> 3
```

#### 2.1.3. 总结

条件构造器的用法：

* `QueryWrapper` 和 `LambdaQueryWrapper` 通常用来构建 select、delete、update 的 where 条件部分
* `UpdateWrapper` 和 `LambdaUpdateWrapper` 通常只有在 set 语句比较特殊才使用
* 尽量使用 `LambdaQueryWrapper` 和 `LambdaUpdateWrapper` ，避免硬编码

### 2.2. 自定义 SQL

#### 2.2.1. 介绍

利用 MyBatisPlus 的 Wrapper 来构建复杂的 Where 条件，然后自己定义 SQL 语句中剩下的部分。

需求：将 id 在指定范围的用户（例如 1、2、4 ）的余额扣减指定值

```xml
<!-- 直接在 mapper.xml 文件中写，WHERE 相对来说很繁琐 -->
<update id="updateBalanceByIds">    
  UPDATE user     
  SET balance = balance - #{amount}    
  WHERE id IN    
    <foreach collection="ids" separator="," item="id" open="(" close=")">        
    #{id}    
    </foreach>
</update>
```

```java
// setSql() 直接在 业务层写 SQL 语句，违反开发规范

List<Long> ids = List.of(1L, 2L, 4L);
UpdateWrapper<User> wrapper = new UpdateWrapper<User>()
        .setSql("balance = balance - 200   ")
        .in("id", ids);
int updateCount = userMapper.update(null, wrapper);
```

```xml
<!-- 这种复杂的 SELECT 子句如果通过 MP 的 select() 直接写 SQL 就会违反开发规范 -->
<update id="selectXxx">
  SELECT status, COUNT(id) AS total
  FROM tb_user
  <where>    
    <if test="name != null">AND username LIKE #{name}</if>    
    <if test="ids != null">        
      AND id IN        
        <foreach collection="ids" open="(" close=")" item="id" separator=",">            
          #{id}        
        </foreach>    
    </if>
  </where>
  GROUP BY status
</update>
```

#### 2.2.2. 步骤

步骤1: 基于 Wrapper 构建 WHERE 条件

```java
List<Long> ids = List.of(1L, 2L, 4L);
int amount = 200;

// 1.构建条件
LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<User>().in(User::getId, ids);

// 2.自定义 SQL 方法调用
userMapper.updateBalanceByIds(wrapper, amount);

/*
==>  Preparing: UPDATE user SET balance = balance - ? WHERE (id IN (?,?,?))
==> Parameters: 200(Integer), 1(Long), 2(Long), 4(Long)
<==    Updates: 3
  */
```

步骤2: 在 mapper 方法参数中用 `@Param("ew")` 声明 wrapper 变量名称

```java
public interface UserMapper extends BaseMapper<User> {
    // 建议使用 @Param(Constants.WRAPPER) 替代 @Param("ew")  
    // com.baomidou.mybatisplus.core.toolkit.Constants.Constants.WRAPPER = "ew"
    void updateBalanceByIds(@Param("ew") LambdaQueryWrapper<User> wrapper, @Param("amount") int amount);
}
```

步骤3: 自定义SQL，并使用 Wrapper 条件

```xml
<update id="updateBalanceByIds">
    UPDATE user
    SET balance = balance - #{amount}
    <!-- 下面就是 wrapper 构造的 WHERE 子句 -->
    ${ew.customSqlSegment}
</update>
```