<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2025-12-09 12:24:39
@modify date 2025-12-23 12:37:24
@desc [description]
#endregion-->

# SpringBoot教程-黑马

>https://www.bilibili.com/video/BV15b4y1a7yG

课程设计:

1. 基础篇
   * 会用
2. 应用篇
   * 补全知识树
   * 加强应用
   * 解决能力
3. 原理篇
   * 提升理解层次
   * 能够自定义
4. 番外篇
   * 丰富视野
   * 提升方案能力

课程学习目标:

1. 基础篇
   * 能够创建 SpringBoot 工程
   * 基于 SpringBoot 实现 ssm 整合
2. 实用篇
   * 运维实用篇
      * 掌握 SpringBoot 程序多环境开发
      * 基于 Linux 系统发布 SpringBoot 工程
      * 解决线上灵活配置 SpringBoot 工程的需求
   * 开发实用篇
      * 基于 SpringBoot 整合任意第三方技术
3. 原理篇
   * 掌握 SpringBoot 内部工作流程
   * 理解 SpringBoot 整合第三方技术的原理
   * 实现自定义开发整合第三方技术的组件

## 1. 基础篇-入门案例

目录:

* 快速上手 SpringBoot
* SpringBoot 基础设置
* 基于 SpringBoot 实现 SSM 整合

### 1.1. 创建项目

SpringBoot：

* 设计目的: 简化 Spring 应用的 初始搭建 以及 开发过程

创建项目 - 基于 SpringBoot initializer:

* 基于阿里云创建项目，地址: https://start.aliyun.com (可以使用 JDK8)
* 基于官网创建项目，地址: https://start.spring.io (不可以使用 JDK8)


创建项目 - 手动:

```xml
<!-- POM.xml -->

<groupId>org.example</groupId>
<artifactId>springboot_01_01_quickstart</artifactId>
<version>0.0.1-SNAPSHOT</version>

<parent>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-parent</artifactId>
   <version>2.5.4</version>
</parent>
<dependencies>
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
</dependencies>
```

### 1.2. 隐藏文件（夹）

IDEA 中隐藏文件（夹）:

* Settings -> Editor -> File Types: Ignored Files and Folder
* 比如隐藏: .idea 目录

### 1.3. 入门案例解析

Spring 程序缺点:

* 依赖设置繁琐
* 配置繁琐

SpringBoot 程序优点:

* 起步依赖（简化依赖配置）
* 自动配置（简化常用工程相关配置）
* 辅助功能（内置服务器， ......）

SpringBoot 通过如下四件事做到的:

* parent
* starter
* 引导类
* 内嵌 Tomcat

### 1.4. 入门案例解析 - parent

>定义所有的依赖和版本，但未使用

通过官网初始化器创建的项目: (pom.xml)

```xml
继承 spring-boot-starter-parent

      继承 spring-boot-dependencies
```

spring-boot-dependencies: (pom.xml)

```xml
<!-- 自定义属性名 -->
<properties>
   定义 所有的可能用到的依赖 的版本信息
</properties>

<!-- 集中管理所有依赖 (仅定义未使用) -->
<dependencyManagement>
   定义 所有的可能用到的依赖
</dependencyManagement>
```

项目中引入依赖:

```xml
<!-- 如果在 dependencyManagement 中存在，则不需要写版本号 -->
<dependency>
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson</artifactId>
</dependency>
```

阿里云初始化器创建的项目: (pom.xml)

```xml
<properties>
   <spring-boot.version>2.7.6</spring-boot.version>
</properties>

<!-- 
   通过 引入依赖的方式 使用 spring-boot-dependencies
   好处: 继承 只能有一次，但 依赖 可以有多个
 --> 
<dependencyManagement>
   <dependencies>
      <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>${spring-boot.version}</version>
            <type>pom</type>
            <scope>import</scope>
      </dependency>
   </dependencies>
</dependencyManagement>
```

小结:

1. 开发 SpringBoot 程序要继承 spring-boot-starter-parent
2. spring-boot-starter-parent 中定义了若干个依赖管理
3. 继承 parent 模块可以避免多个依赖使用相同技术时出现依赖版本冲突
4. 继承 parent 的形式也可以采用引入依赖的形式实现效果

parent:

* 定义了很多依赖坐标版本（依赖管理，而非依赖），以达到减少依赖冲突的目的
* spring-boot-starter-parent 不同版本之间，涉及的依赖的版本“大部分”不一样

### 1.5. 入门案例解析 - starter

>包含若干个 依赖 的 pom 文件

starter:

* SpringBoot 中常见项目名称，定义了 该项目 使用的所有依赖 的坐标，以达到减少依赖配置的目的
* xyz-starter: 包含 xyz 技术涉及的所有依赖，由于依赖的传递性，我们的项目相当于也导入了这些必须的依赖

实际开发:

* 使用坐标时，GAV 中，只写 GA
* 刷新 Maven 后
   * 不报错，说明 SpringBoot 提供了该坐标的版本
   * 报错，则需要手动指定 V

小结:

* 开发 SpringBoot 应用时，导坐标时，通常导入对应的 starter
* starter 通常包含多个依赖坐标
* 使用 starter 可以实现快速配置的效果，达到简化配置的目的

parent 和 starter 都是解决配置问题，但运行程序仅有配置是不行的

### 1.6. 入门案例解析 - 引导类

启动方式:

```java
/**
 * 包含如下注解:
 *
 *  @Configuration 配置类
 *
 *  @ComponentScan 默认扫描 当前类 所在的包及其子包
 */
@SpringBootApplication
public class App {
    public static void main(String[] args) {
        // 初始化 IoC 容器
        ConfigurableApplicationContext ctx = SpringApplication.run(App.class, args);

        BookController bean = ctx.getBean(BookController.class);
        System.out.println("bean = " + bean);
        //=> org.example.controller.BookController@58065f0c
    }
}
```

SpringBoot 的引导类是 Boot 工程的执行入口，运行 `main()` 方法就可以启动项目。

SpringBoot 工程运行后初始 Spring 容器，扫描引导类所在的包加载 bean

小结:

* SpringBoot 工程提供引导类用来启动程序
* SpringBoot 工程启动后创建并初始化 Spring 容器

### 1.7. 入门案例解析 - 辅助功能 - 内嵌 tomcat

内嵌 Tomcat:

```xml
spring-boot-starter-web
   spring-boot-starter-tomcat
      tomcat-embed-core
```

切换为 Jetty:

```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-web</artifactId>
   <exclusions>
         <!-- 排除 Tomcat -->
         <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
         </exclusion>
   </exclusions>
</dependency>

<!-- 
   使用 Jetty
   Jetty 比 Tomcat 更轻量级，可扩展性更强(相较于Tomcat)， 谷歌应用引擎(GAE)已经全面切换为Jetty 。
   如果是小型应用，建议使用 Jetty
-->
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
```

内置服务器:

* tomcat (默认)
   * Apache 出品，粉丝多，应用面广，负载了若干较重的组件
* jetty
   * 更轻量级，负载性能（并发性能）远不及 tomcat
* undertow
   * 负载性能勉强跑赢 tomcat

小结:

* 内嵌 tomcat 服务器是 SpringBoot 辅助功能之一
* 内嵌 tomcat 工作原理是将 tomcat 服务器作为对象运行，并将该对象交给 Spring 容器管理
* 变更内嵌服务器: 排除现有服务器的 starter，添加新的服务器 starter

## 2. 知识加油站 - REST

REST:

* 新的访问资源的格式
* 旧的: (传统风格资源描述形式)
   * 增: `POST /user/saveUser`
   * 删: `POST /user/removeById`
   * 改: `POST /user/updateUser`
   * 查: `POST /user/getById` (单个)
   * 查: `POST /user/getList` (多个)
* 新的: (REST 风格描述形式)
   * 增: `POST    /users`
   * 删: `DELETE  /users/{id}`
   * 改: `PUT     /users`
   * 查: `GET     /users/{id}` (单个)
   * 查: `GET     /users`      (多个)

优点:

* 隐藏资源访问行为，无法通过 URI 得知对资源是何种操作
* 简化书写

风格:

* 风格是约定、建议，可以不遵守
* 虽然不是规范，但是大家都这么做，就变成了事实上的规范了

RESTful:

* 使用 REST 风格访问资源（的行为）称为 RESTful

## 3. 基础篇 - 基础配置

目录:

* 属性配置
* 配置文件分类
* yaml 文件
* yaml 数据读取

### 3.1. 教你一招：复制模块

原则:

* 保留工程基础结构
* 抹掉原始工程痕迹

步骤 1. 拷贝原始工程的目录并重命名

```text
拷贝 
   SpringBootDemo/springboot_01_01_quickstart

重命名
   SpringBootDemo/springboot_0x_abc
```

步骤 2. 删除无用的目录和文件，仅保留 src 、 pom.xml

步骤 3. 修改 pom.xml，改 artifactId，删 name、description

```xml
<!-- 修改 artifactId 为目录名称 -->
<artifactId>springboot_0x_abc</artifactId>

<!-- 
   删除 <name> <description> , 没有实际的作用
   Maven 面板中的项目名称会优先显示 name，如果没有 name 则显示 artifactId
--> 
<name>springboot_01_01_quickstart</name>
<description>desc</description>
```

步骤 4. IDEA 中导入模块后刷新 Maven

```text
1. Project Structure

2. Import Module
      Import Module from external model
         Maven
```

小结：

1. 在工作空间中复制对应工程，并修改工程名称
2. 删除 IDEA 相关配置目录与文件，仅保留 src 目录和 pom.xml 文件
3. 修改 pom.xml 文件中的 artifactId （与模块名一致）
4. 删除 name 标签
5. 保留备份工程供后期使用

### 3.2. 基础配置

配置文件位置:

* resources/application.properties


配置的官方文档:

* https://docs.spring.io/spring-boot/docs/2.5.4/reference/html/application-properties.html


配置文件中的配置由来:

* 配置项是由依赖包提供的
* 也就是说引入了对应技术的依赖，在配置文件里才有对应配置(及推荐)

### 3.3. 三种配置文件类型

application.properties (传统格式/默认格式)

```properties
server.port=80
```

application.yml (主流格式)

```yml
server:
   port: 81
```

application.yaml

```yml
server:
   port: 82
```

### 3.4. 配置文件加载优先级

当三个配置文件都存在时

加载的顺序: (优先级 从高到低)

1. application.properties
2. application.yml
3. application.yaml


配置项:

* 配置项都保留: 三个文件的配置项会合并
* 冲突的配置项: 取 优先级高的文件 的配置项

### 3.5. 教你一招：属性提示消失解决方案

问题:

* 在 application.yaml 书写配置时，没有提示（推荐）

原因:

* IDEA 未能将 application.yaml 识别为 SpringBoot 的配置文件

解决: (IDEA 2025.3)

```text
1. 打开 Project Structure
   
2. 切换到 Modules 页签

3. 选中（有 application.yaml 的）项目/工程

4. 点击 “+”，下拉菜单里选择 “Spring” 即可
```

### 3.6. yaml 数据格式

YAML:

* 一种数据序列化格式

优点:

* 容易阅读
* 容易与脚本语言交互
* 以数据为核心，重数据 轻格式

扩展名:

* .yml (主流)
* .yaml

语法规则:

* 大小写敏感
* 多层属性名 用多行描述，每行属性名结尾跟冒号
* 使用（空格）缩进表示层级关系，同层级左侧对齐
* 属性值前加空格（属性名 与 属性值 之间用空格和冒号隔开）
* `#` 表示注释

字面值:

* boolean
   * 真: true / True / TRUE
   * 假: false / False / FALSE
* float
   * eg: 3.14, 1.2e+5
* int
   * eg: 123
* null
   * 用 `~` 表示
* string
   * 普通字符串: 直接书写
   * 特殊字符串: 用双引号包裹
   * eg: `"Zhang San"` (包含空格，使用双引号包裹)
* date
   * 必须使用 yyy-MM-dd 格式
   * eg: 2025-02-13
* datetime
   * 格式: `日期T时间+时区`
   * eg: `2025-02-13T12:07:25+08:00`

数组:

```yml
# 数组 - 基本类型元素
hobbies:
  - game
  - read
  - sleep

# 数组 - 基本类型元素 - 缩略
hobbies2: [game, read, sleep]

# 数组 - 对象类型元素 - 格式 1
persons:
  - name: wangwu
    age: 21
  - name: zhanliu
    age: 29

# 数组 - 对象类型元素 - 格式 2
persons2:
  -
    name: wangwu
    age: 21
  -
    name: zhanliu
    age: 29

# 数组 - 对象类型元素 - 缩略
persons3: [{name:wangwu, age:21}, {name:zhanliu, age:29}]
```

### 3.7. 读取 yaml 单一属性数据

使用 `@Value` 配合 SpEL 读取单个数据

如果数据存在多层级，依次书写层级名称即可

示例:

```java
@Value("${flag}")
private Boolean flag;

@Value("${person.name}")
private String name;

@Value("${persons2[1].age}") // 数组索引从 0 开始
private Integer age;
```

### 3.8. yaml 文件中的引用其它属性

在配置文件中使用 `${属性名}` 引用其它属性的值

如果属性中有特殊字符（比如转义字符 `\n`），需要使用双引号包裹

```yml
baseDir: C:\window

tempDir: ${baseDir}\tmp

# 双引号包裹的字符串，其中的转义字符会生效
tempDir2: "${baseDir}:\n 1.xxx \n 2.yyy"
```

### 3.9. 读取 yaml 全部属性数据

Environment 对象封装了全部配置信息，通过 `@Autowire` 注入并使用:

```java
// 注入封装了全部属性的 Environment 对象
@Autowired
private Environment env;

// 读取属性
env.getProperty("person.name")
```

### 3.10. 读取 yaml 引用类型属性数据

使用 `@ConfigurationProperties(prefix = "1级属性名")` 注解绑定配置信息到封装类

封装类需要交给 Spring 管理

```java
/*
person:
  name: lisi
  age: 20
*/

@Component
@ConfigurationProperties(prefix = "person")
@Data
public class Person {
    private String name;
    private Integer age;
}
```

## 4. 基础篇 - 整合第三方技术

* 整合 JUnit
* 整合 MyBatis
* 整合 MyBatis-Plus
* 整合 Druid

### 4.1. 整合 JUnit

步骤:

1. 导入测试对应的 starter
2. 测试类使用 `@SpringBootTest` 修饰
3. 使用自动装配的形式添加要测试的对象

示例:

```java
@Repository
public class BookDaoImpl implements BookDao {
    @Override
    public void save() {
        System.out.println("Book Dao is running...");
    }
}


@SpringBootTest
class Springboot03JunitApplicationTests {
    @Autowired
    private BookDao bookDao;

    @Test
    void contextLoads() {
        bookDao.save();
    }
}
```

### 4.2. 整合 JUnit - classes 属性

测试类如果不在 引导类所在的包或子包，则需要通过 `@SpringBootTest(classes=引导类)` 来显式指定

### 4.3. 整合 MyBatis

配置:

* 核心配置: 数据库连接相关信息
* 映射配置: SQL 映射（XML/注解）

starter 的 artifactId 名称惯例:

* Spring 官方的 starter: spring-boot-starter-技术名
* 第三方技术的 starter: 技术名-spring-boot-starter

步骤 1. 创建项目时勾选 “ SQL -> MyBatis Framework ” 、“ SQL -> MySQL Driver ”

```xml
<dependency>
   <groupId>org.mybatis.spring.boot</groupId>
   <artifactId>mybatis-spring-boot-starter</artifactId>
   <version>2.2.2</version>
</dependency>
<dependency>
   <groupId>mysql</groupId>
   <artifactId>mysql-connector-java</artifactId>
   <scope>runtime</scope>
</dependency>
```

步骤 2. 数据连接相关信息 (application.yml)

```yml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/springboot_db
    username: root
    password: 123456
```

步骤 3. 在 dao 接口上添加 `@Mapper` 才能被容器识别

```java
@Mapper
public interface BookDao {
    @Select("select * from tbl_book where id = #{id}")
    public Book getById(Integer id);
}
```

步骤 4. 测试

```java
@SpringBootTest
class Springboot04MybatisApplicationTests {
    @Autowired
    private BookDao bookDao;

    @Test
    void contextLoads() {
        System.out.println(bookDao.getById(1));
    }
}
```

### 4.4. 整合 MyBatis - 常见问题处理

MySQL 8.x 要求设置时区:

* 方式 1: 修改 URL, 添加 `serverTimezone=UTC`
* 方式 2: 修改 MySQL 配置文件(mysql.ini)

驱动过时警告:

* 使用 `com.mysql.cj.jdbc.Driver` 驱动类

### 4.5. 整合 MyBatisPlus

步骤 1. 添加 MP 的坐标

```xml
<dependency>
   <groupId>com.baomidou</groupId>
   <artifactId>mybatis-plus-boot-starter</artifactId>
   <!-- 
      PaginationInnerInterceptor 已分离出来。
      如需使用，则需单独引入 mybatis-plus-jsqlparser 依赖  
    -->
   <version>3.5.7</version>
</dependency>
<dependency>
   <groupId>mysql</groupId>
   <artifactId>mysql-connector-java</artifactId>
   <scope>runtime</scope>
</dependency>
```

步骤 2. 数据连接相关信息

```yml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/springboot_db
    username: root
    password: 123456
mybatis-plus:
  global-config:
    db-config:
      table-prefix: tbl_
```

步骤 3. 给 dao 接口继承 BaseMapper

```java
@Mapper
public interface BookDao extends BaseMapper<Book> {
}
```

步骤 4. 测试

```java
@SpringBootTest
class Springboot05MybatisplusApplicationTests {
    @Autowired
    private BookDao bookDao;

    @Test
    void contextLoads() {
        System.out.println(bookDao.selectById(1));
    }
}
```

### 4.6. 整合 Druid

步骤 1. 导入 Druid 的 starter (中央仓库上搜 “druid”)

```xml
<dependency>
   <groupId>com.alibaba</groupId>
   <artifactId>druid-spring-boot-starter</artifactId>
   <version>1.2.27</version>
</dependency>

<dependency>
   <groupId>com.baomidou</groupId>
   <artifactId>mybatis-plus-boot-starter</artifactId>
   <version>3.5.7</version>
</dependency>
<dependency>
   <groupId>mysql</groupId>
   <artifactId>mysql-connector-java</artifactId>
   <scope>runtime</scope>
</dependency>
```

步骤 2. 配置 Druid

```yml
# 方式一: 指定 druid 数据源即可
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/springboot_db
    username: root
    password: 123456
    type: com.alibaba.druid.pool.DruidDataSource

# 方式二: 在 spring.datasource.druid 下配置 【推荐】
spring:
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/springboot_db
      username: root
      password: 123456
```

步骤 3. 测试


整合第三方技术的通用方式:

* 导入对应的 starter
* 根据提供的配置格式，配置非默认值对应的配置项

## 5. 基础篇 - SSMP 整合案例

### 5.1. 案例实现方案分析

案例实现方案分析:

* POJO: 使用 Lombok 快速制作实体类
* Dao: MyBatisPlus，开发与测试
* Service: MyBatisPlus，开发与测试
* Controller: Restful，PostMan 测试接口
* 页面: Vue + ElementUI
* 项目异常处理
* 按条件查询

### 5.2. 模块创建

1. SpringBoot initializer: 勾选 Spring Web 和 MySQL Driver
2. 修改配置文件的后缀名为 yml
3. 设置服务器的端口为 80

### 5.3. 实体类快速开发 - lombok

Lombok，提供一组注解，简化 POJO 实体类的开发

```xml
<!-- lombok 的版本由 SpringBoot 提供 -->
<dependency>
   <groupId>org.projectlombok</groupId>
   <artifactId>lombok</artifactId>
</dependency>
```

示例:

```java
// 为当前实体类在 编译期 设置如下方法: 
// getter / setter / toString / hashCode / equals
@Data
public class Book {
    private Integer id;
    private String name;
    private String type;
    private String description;
}
```

### 5.4. 数据层开发 - 基础 CRUD

技术实现方案:

* Druid
* MyBatisPlus

小结:

1. 手动导入 starter
2. 配置 数据源 和 MyBatisPlus
3. 开发 Dao 接口(继承 BaseMapper)
4. Dao 功能的测试

### 5.5. 开启 MP 运行日志

```yml
mybatis-plus:
  configuration:
    # 输出到控制台
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

### 5.6. MP 分页

分页操作是 MP 的增强功能，内部是动态拼写 SQL 语句，使用 MP 的拦截器实现:

```java
package org.example.config;

@Configuration
public class MpConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        // 分页插件: MP v3.5.8 之后的版本需要单独引入依赖
        // 使用 3.5.8 的版本，启动会报错，原因位置，使用 3.5.7 不报错
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return mybatisPlusInterceptor;
    }
}
```

分页操作需要设置 分页对象 IPage，其中封装了分页操作中的所有数据:

```java
@Test
void testGetPage() {
    IPage<Book> page = Page.of(1, 5);
    bookDao.selectPage(page, null);
    // 页码
    long pageIndex = page.getCurrent();
    // 页大小
    long pageSize = page.getSize();
    // 总页数
    long pages = page.getPages();
    // 总记录数
    long total = page.getTotal();
    // 该页的记录
    List<Book> records = page.getRecords();
}
```

### 5.7. 数据层标准开发 - 条件查询

小结:

1. 使用 QueryWrapper / LambdaQueryWrapper 封装查询条件
2. 所有查询操作封装成方法调用
3. 查询条件支持动态条件拼装

### 5.8. 业务层标准开发 - 基础 CRUD

service 层接口: 

* 业务相关，使用 业务名称 作为接口名称
* 比如: `login(String username, String password)`

dao 层接口: 

* 数据操作，使用 操作数据的行为 作为接口名称
* 比如: `selectByUserNameAndPassword(String username, String password)`


### 5.9. 业务层快速开发 - 基于 MP 构建

快速开发方案:

* 使用 MP 提供的 业务层接口(`IService<PO>`) 与实现类(`ServiceImpl<DAO, PO>`)

### 5.10. 表现层标准开发

基于 Restful 制作表现层接口:

* 新增: POST
* 删除: DELETE
* 修改: PUT
* 查询: GET

接收参数:

* 实体数据: `@RequestBody`
* 路径变量: `@PathVariable`

### 5.11. 表现层数据一致性处理 - R 对象

表现层结果的模型类，统一前后端数据格式，也称为 前后端数据协议

```java
@Data
@NoArgsConstructor
@AllArgsConstructor(staticName = "of")
public class R {
    private Boolean flag;
    private Object data;
    private String msg;

    public static R ok() {
        return R.of(true, null, "ok");
    }

    public static R ok(Object data) {
        return R.of(true, data, "ok");
    }

    public static R fail(String msg) {
        return R.of(false, null, msg);
    }
}
```

### 5.12. 前后端调用

单体项目中页面放置在 resources/static 目录下，默认可以直接访问

### 5.13. 异常消息处理

```java
package org.example.controller.utils;

// @RestControllerAdvice = @ControllerAdvice + @ResponseBody
@RestControllerAdvice
public class ProjectExceptionAdvice {
    // 拦截指定类型的异常
    // @ExceptionHandler(RuntimeException.class)
    
    // 默认拦截处理所有异常
    @ExceptionHandler
    public R doException(Exception e) {
        e.printStackTrace();
        return R.fail("服务器故障，请稍后重试");
    }
}
```

### 5.14. 分页功能维护 - 删除 BUG

问题:

* 如果最后一页，只有一条数据，此时删除该条数据，会导致 分页查询当前页 时数据为空

解决:

* 后台处理: 分页查询，如果当前页比总页数还大，则将总页数作为当前页再次查询并返回
* 前台处理: 删除之后，返回第一页

## 6. 运维实用篇 - 打包与运行

程序打包与运行（Windows版）

程序运行（Linux版）

### 6.1. 打包与运行 - Windows

打包:

```shell
# 会执行测试代码
mvn package

# ‌跳过测试但不跳过单元测试编译
mvn package -DskipTests

# 完全跳过测试阶段‌
mvn package -DskipTests -Dmaven.test.skip=true
```

运行:

```shell
java -jar springboot.jar
```

maven 插件:

```xml
<!-- 
   jar 包 如果想在命令行运行，需要配置如下 maven 插件
-->
<build>
   <plugins>
      <plugin>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
   </plugins>
</build>
```

### 6.2. 打包插件

使用 压缩软件 打开 springboot.jar:

```text
springboot.jar/
   BOOT-INF/      # 项目资源
      classes/       # 类
      lib/           # 依赖
   META-INF/      # 清单
      MANIFEST.MF
   org/           # SpringBoot 启动器
```

MANIFEST.MF: (基于 spring-boot-maven-plugin 打包的工程)

```properties
# 启动类(引导类)
Start-Class: org.example.Springboot07SsmpApplication
# Jar 启动器
Main-Class: org.springframework.boot.loader.JarLauncher
```

windows 上端口被占用的处理，相关命令:

```shell
# 查询指定端口的进程 PID
netstat -ano | findstr ":80"
# 协议   本地地址       外部地址     状态        PID
# TCP    0.0.0.0:80    0.0.0.0:0   LISTENING   9144


# 根据进程 PID 查询进程名称
tasklist | findstr "9144"
# 映像名称   PID      会话名   会话#   内存使用
# java.exe  9144     Console  1      17,256 K


# 根据 PID 杀死进程
taskkill /f /pid "9144"
# 成功: 已终止 PID 为 9144 的进程。


# 根据进程名称杀死任务
taskkill -f -t -im "进程名称"
```

### 6.3. 运行 - Linux

安装包（jar）存放目录: 

* /usr/local/自定义目录
* $HOME/自定义目录

后台运行:

```shell
nohup java -jar springboot.jar > server.log 2>&1 &
```

终止服务:

```shell
# 查 PID
ps -ef | grep "java -jar"

# 杀 进程
kill -9 进程ID
```

## 7. 运维实用篇 - 配置高级

临时属性设置

配置文件分类

自定义配置文件

### 7.1. 临时属性 - 命令行参数

启动时，通过临时属性替换配置文件的属性:

```shell
# 格式: 
# java -jar xyz.jar --属性1=值1 --属性2=值2

# 示例:
java -jar springboot.jar --server.port=8080
```

### 7.2. 临时属性 - 开发环境

在 IDEA 中设置临时属性:

* Run/Debug Configuration -> Build And Run -> Modify Options
* 勾选 Java -> Program Arguments，输入 `--server.port=8081` 即可

运行 IDEA 中的该运行配置，相当于如下命令:

```shell
java -jar springboot.jar --server.port=8081
```

原理: 通过 main() 方法接收的命令行参数会传入 SpringBoot 启动器

```java
@SpringBootApplication
public class Springboot07SsmpApplication {

    // main() 方法的 args 参数接收命令行参数
    public static void main(String[] args) {
        System.out.println(Arrays.toString(args));
        //=> [--server.port=8081]

        // 命令行参数 传入 SpringBoot 后生效
        SpringApplication.run(Springboot07SsmpApplication.class, args);

        // 启动时，不接收命令参数
        // SpringApplication.run(Springboot07SsmpApplication.class);
    }
}
```

## 8. 运维实用篇 - 多环境开发
## 9. 运维实用篇 - 日志


