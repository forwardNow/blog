<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2025-09-19 16:48:39
@modify date 2025-11-01 15:44:59
@desc [description]
#endregion-->


# redis-实战篇

目录:

* 短信登录

   * Redis 的共享 session 应用

* 商户查询缓存

   * 企业的缓存使用技巧
   * 解决 缓存雪崩、穿透 等问题

* 优惠券秒杀

   * Redis 的计数器、Lua 脚本 Redis
   * 分布式锁
   * Redis 的三种消息队列

* 达人探店

   * 基于 List 的点赞列表
   * 基于 SortedSet 的点赞排行榜

* 好友关注

   * 基于 Set 集合的关注、取关、共同关注
   * 消息推送等功能

* 附近的商户

   * Redis 的 GeoHash 的应用
   
* 用户签到

   * Redis 的 BitMap 数据统计功能

* UV统计

   * Redis 的 HyperLogLog 的统计功能

## 1. 短信登录

### 1.1. 导入黑马点评项目

表:

* tb_user: 用户
* tb_user_info: 用户详情 
* tb_shop: 商户信息
* tb_shop_type: 商户类型
* tb_blog: 用户日记
* tb_follow: 用户关注
* tb_voucher: 优惠券
* tb_voucher_order: 优惠券的订单

架构:

![image-20250928122620186](./images/image-20250928122620186.png)

测试:

* 服务端: http://localhost:8081/api/shop-type/list
* 客户端: http://localhost:8080 (移动端Web模式)
   * 启动 Ngxin: `start nginx.exe` (CMD)

### 1.2. 基于 Session 实现登录

#### 1.2.1. 流程

![image-20250928214129757](./images/image-20250928214129757.png)

#### 1.2.2. 发送验证码

```java
@Service
@Slf4j
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {

    @Override
    public Result sendCode(String phone, HttpSession session) {
        // 1. 校验手机号
        boolean phoneInvalid = RegexUtils.isPhoneInvalid(phone);

        // 2. 如果校验失败，则返回错误信息
        if (phoneInvalid) {
            return Result.fail("手机号格式错误");
        }

        // 3. 校验成功，生成验证码 (cn.hutool.core.util.RandomUtil)
        String code = RandomUtil.randomNumbers(6);

        // 4. 保存验证码到 session
        session.setAttribute("code", code);

        // 5. 发送验证码到手机 (直接在控制台打印)
        log.debug("发送验证码成功，验证码为: {}", code);

        // 返回 成功
        return Result.ok();
    }
}
```

#### 1.2.3. 短信验证码登录和注册

```java
@Override
public Result login(LoginFormDTO loginForm, HttpSession session) {
   String phone = loginForm.getPhone();

   // 1. 校验手机号
   boolean phoneInvalid = RegexUtils.isPhoneInvalid(phone);
   // 1.1 如果校验失败，则返回错误信息
   if (phoneInvalid) {
      return Result.fail("手机号格式错误");
   }

   // 2. 校验验证码
   String code = loginForm.getCode();
   Object cachedCode = session.getAttribute("code");

   // 2.1 不一致，报错
   if (cachedCode == null || !cachedCode.toString().equals(code)) {
      return Result.fail("验证码错误");
   }

   // 3. 根据手机号查询用户
//        User user = lambdaQuery().eq(User::getPhone, phone).one(); // ?? 为什么不可以
   User user = query().eq("phone", phone).one();

   // 4. 用户不存在则创建
   if (user == null) {
      user = createUserWithPhone(phone);
   }

   // 5. 保存用户信息到 session
   session.setAttribute("user", user);

   return Result.ok();
}

private User createUserWithPhone(String phone) {
   User user = new User();

   user.setPhone(phone);
   user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(6));

   save(user);

   return user;
}
```

#### 1.2.4. 登录校验拦截器

UserHolder:

```java
public class UserHolder {
    private static final ThreadLocal<User> tl = new ThreadLocal<>();

    public static void saveUser(User user){
        tl.set(user);
    }

    public static User getUser(){
        return tl.get();
    }

    public static void removeUser(){
        tl.remove();
    }
}
```

拦截器: 

```java
/**
 * 每个请求处理之前 都判断 session 中是否有 user,
 *    有 则 存入 ThreadLocal，供后续方法进行处理，并放行
 *    无 则 返回 401，不放行
 * 请求处理完毕，则销毁掉 ThreadLocal 中的 User
 */
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 获取 session
        HttpSession session = request.getSession();

        // 2. 获取 session 中的用户
        Object user = session.getAttribute("user");

        // 3. 用户不存在，拦截 并返回 401 或抛异常
        if (user == null) {
            log.info("用户不存在");
            response.setStatus(401);
            return false;
        }

        // 4. 用户存在，存入 ThreadLocal
        UserHolder.saveUser((User) user);

        // 5. 放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        UserHolder.removeUser();
    }
}
```

注册拦截器:

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry
                .addInterceptor(new LoginInterceptor())
                // 排除（不拦截）
                .excludePathPatterns(
                        "/shop/**",
                        "/shop-type/**",
                        "/voucher/**",
                        "/upload/**",
                        "/blog/hot",

                        "/user/code",
                        "/user/login"
                );
    }
}
```

#### 1.2.5. 隐藏用户敏感信息

说明:

* 接口返回的 User 是一个完整的对象，包含用户所有的信息，其中有很多敏感的数据
* ThreadLocal 里存储的 User 越小越好

### 1.3. 集群的 Session 共享问题

![image-20250930085621764](./images/image-20250930085621764.png)

session 共享问题:

* 多台 Tomcat 并不共享 session 存储空间，当请求切换到不同 Tomcat 服务时导致数据丢失的问题

session 的替代方案应该满足:

* 数据共享
* 内存存储
* key、value 结构

### 1.4. 基于 Redis 实现共享 Session 登录

#### 1.4.1. Redis 代替 session 的业务流程

发送短信验证码:

![image-20250930122127850](./images/image-20250930122127850.png)

短信验证码登录、注册:

![image-20250930122137450](./images/image-20250930122137450.png)

校验登录状态:

![image-20250930122142215](./images/image-20250930122142215.png)


#### 1.4.2. 发送短信验证码

```java
public class RedisConstants {
    public static final String LOGIN_CODE_KEY = "login:code:";
    public static final Long LOGIN_CODE_TTL = 2L;
}

// ...

@Autowired
private StringRedisTemplate stringRedisTemplate;

// 4. 保存验证码到 redis
stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + "phone", code, LOGIN_CODE_TTL, TimeUnit.MINUTES);
```

#### 1.4.3. 短信验证码登录、注册

```java
@Override
public Result login(LoginFormDTO loginForm, HttpSession session) {
   String phone = loginForm.getPhone();

   // 1. 校验手机号
   boolean phoneInvalid = RegexUtils.isPhoneInvalid(phone);
   // 1.1 如果校验失败，则返回错误信息
   if (phoneInvalid) {
      return Result.fail("手机号格式错误");
   }

   // 2. 校验验证码
   String code = loginForm.getCode();
   String cachedCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);

   // 2.1 不一致，报错
   if (cachedCode == null || !cachedCode.equals(code)) {
      return Result.fail("验证码错误");
   }

   // 3. 根据手机号查询用户
   User user = query().eq("phone", phone).one();

   // 4. 用户不存在则创建
   if (user == null) {
      user = createUserWithPhone(phone);
   }

   // 5. 保存用户信息到 redis

   // 5.1 生成随机 token (uuid)
   String token = UUID.randomUUID().toString(true); // true - 不带中划线的 UUID

   // 5.2 将 user 转 Map
   UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);

   // stringRedisTemplate 要求 Hash 值中的 value 必须为 String
   CopyOptions copyOptions = CopyOptions.create()
            .setIgnoreNullValue(true)
            .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString());
   Map<String, Object> userMap = BeanUtil.beanToMap(userDTO, new HashMap<>(), copyOptions);

   // 5.3 将 userMap 存储到 Redis
   String tokenKey = LOGIN_USER_KEY + token;
   stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);

   // 5.4 设置 token 有效期
   stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);

   // 6. 将 token 返回给前端
   return Result.ok(token);
}
```

#### 1.4.4. 校验登录状态

```java
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {
    private final StringRedisTemplate stringRedisTemplate;

    public LoginInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 获取请求头中 token
        String token = request.getHeader("authorization");

        // 1.1 不能存在，则返回 401
        if (StrUtil.isEmpty(token)) {
            log.info("未携带自定义请求头: authorization=token");
            response.setStatus(401);
            return false;
        }

        // 2. 基于 token 获取 Redis 中存储的 user
        String tokenKey = RedisConstants.LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(tokenKey);

        // 3. 用户不存在，拦截 并返回 401 或抛异常
        if (CollectionUtil.isEmpty(userMap)) {
            log.info("用户不存在");
            response.setStatus(401);
            return false;
        }

        // 4. 用户存在，存入 ThreadLocal
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);
        UserHolder.saveUser(userDTO);

        // 5. 刷新 token 有效期
        stringRedisTemplate.expire(tokenKey, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);

        // 6. 放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        UserHolder.removeUser();
    }
}
```

### 1.5. 优化登录拦截器

说明:

* 登录拦截器，拦截 非匿名 请求，校验用户是否登录（ThreadLocal 中是否有 user）
* token 刷新拦截器，拦截所有请求，校验 token 并将 user 保存到 ThreadLocal

![image-20251001111832362](./images/image-20251001111832362.png)

代码:

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Resource
    private StringRedisTemplate stringRedisTemplate;

    // 注册拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate))
                // 拦截器的顺序默认为 0 （越小优先级高），相同则先添加的先执行
                .order(0)
                // 默认就是拦截所有
                .addPathPatterns("/**");

        registry
                .addInterceptor(new LoginInterceptor())
                .order(1)
                // 排除（不拦截）
                .excludePathPatterns(
                        "/shop/**",
                        "/shop-type/**",
                        "/voucher/**",
                        "/upload/**",
                        "/blog/hot",

                        "/user/code",
                        "/user/login"
                );

    }
}

// 刷新 token 拦截器
@Slf4j
public class RefreshTokenInterceptor implements HandlerInterceptor {
    private final StringRedisTemplate stringRedisTemplate;

    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 获取请求头中 token
        String token = request.getHeader("authorization");

        // 1.1 不存在，直接放行 并 返回
        if (StrUtil.isEmpty(token)) {
            log.info("token 为空");
            return true;
        }

        // 2. 基于 token 获取 Redis 中存储的 user
        String tokenKey = RedisConstants.LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(tokenKey);

        // 3. 用户不存在，直接放行 并 返回
        if (CollectionUtil.isEmpty(userMap)) {
            log.info("用户不存在");
            return true;
        }

        // 4. 用户存在，存入 ThreadLocal
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);
        UserHolder.saveUser(userDTO);

        // 5. 刷新 token 有效期
        stringRedisTemplate.expire(tokenKey, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);

        // 6. 放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        UserHolder.removeUser();
    }
}

// 登录拦截器
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 判断 ThreadLocal 中是否有 user，无则返回 401
        if (UserHolder.getUser() == null) {
            log.info("未登录");
            response.setStatus(401);
            return false;
        }
        return true;
    }
}
```

## 2. 商户查询缓存

目录:

* 什么是缓存
* 添加 Redis 缓存
* 缓存更新策略
* 缓存穿透
* 缓存雪崩
* 缓存击穿
* 缓存工具封装

### 2.1. 什么是缓存

缓存:

* 缓存就是数据交换的缓冲区（cache）
* 是存储数据的临时地方，一般读写性能较高

作用:

* 降低后端负载
* 提高读写效率，减少响应时间

成本:

* 数据一致性成本
* 代码维护成本
* 运维成本

### 2.2. 添加 Redis 缓存

功能：

* 添加商户缓存

流程:

1. 从 Redis 查询商铺
2. Redis 里存在，则直接返回
3. Redis 里不存在，则根据 id 查询数据库
4. 数据库 里不存在，返回错误
5. 数据库 里存在，则写入 Redis
6. 返回

### 2.3. 缓存更新策略

策略:

| 策略 | 内存淘汰 | 超时剔除 | 主动更新 |
| - | - | - | - |
| 说明 | 不用自己维护，利用 Redis 的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存 | 给缓存数据添加 TTL 时间，到期后自动删除缓存。下次查询时更新缓存 | 编写业务逻辑，在修改数据库的同时，更新缓存 |
| 一致性 | 差 | 一般 | 好 |
| 维护成本 | 无 | 低 | 高 |

业务场景:

* 低一致性需求: 使用内存淘汰机制。例如 店铺类型 的查询缓存。
* 高一致性需求: 主动更新，并以超时剔除作为兜底方案。例如 店铺详情 的查询缓存

主动更新策略:

* 【√】Cache Aside Pattern 
   * 由缓存的调用者，在更新数据库的同时更新缓存 【主动更新】
* Read/Write Through Pattern
   * 缓存与数据库整合为一个服务，由服务来维护一致性
   * 调用者调用该服务，无需关心缓存一致性问题
* Write Behind Caching Pattern
   * 调用者只操作缓存
   * 由其它线程异步的将缓存数据持久化到数据库，保证最终一致性

主动更新 需要考虑如下问题:

1. 删除缓存还是更新缓存?

   * 更新缓存: 每次更新数据库都更新缓存，无效写操作较多【×】
   * 删除缓存: 更新数据库时让缓存失效，查询时再更新缓存【√】
   
2. 如何保证缓存与数据库的操作 同时成功或失败【事务问题】

   * 单体系统: 将缓存与数据库操作放在同一个事物
   * 分布式系统: 利用 TCC 等分布式事务方案

3. 先操作 缓存 还是先操作 数据库？【线程安全问题】

   * 先删除缓存，再操作数据库【×】
   * 先操作数据库，再删除缓存【√】


分析 “先操作 缓存 还是先操作 数据库”：

![image-20251003175217574](./images/image-20251003175217574.png)

最佳实践:

1. 低一致性需求: 使用 Redis 自带的内存淘汰机制
2. 高一致性需求: 主动更新，并以超时剔除作为兜底方案
   * 读操作
      * 缓存命中则直接返回
      * 缓存未命中则查询数据库，并写入缓存，设定超时时间
   * 写操作
      * 先写数据库，然后再删除缓存
      * 要确保数据库与缓存操作的原子性

案例: 修改 ShopController 中的业务逻辑，满足如下需求

* 根据 ID 查询店铺时，如果换成未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间
* 根据 ID 修改店铺时，先修改数据库，再删除缓存

```java
@Transactional
@Override
public Result update(Shop shop) {
    Long id = shop.getId();

    if (id == null) {
        return Result.fail("店铺ID不能为空");
    }

    // 1. 先修改数据库
    updateById(shop);

    // 2. 再修改Redis
    stringRedisTemplate.delete(GET_CACHE_SHOP_KEY(id));

    return Result.ok();
}
```

### 2.4. 缓存穿透

说明:

* 缓存穿透 是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会到达数据库
* 不断发起这样的请求，会给数据库带来巨大的压力

常见解决方案:

* 缓存空对象【√】
* 布隆过滤

缓存空对象:

* 优点: 实现简单，维护方便
* 缺点: 额外的内存消耗；可能造成短期的不一致

![image-20251009124941399](./images/image-20251009124941399.png)

布隆过滤:

* 优点: 内存占用较少，没有多余 key
* 缺点: 实现复杂; 存在误判的可能

![image-20251009124949395](./images/image-20251009124949395.png)

其他主动方案: （该讲师的 SpringCould 课程里有讲）

* 增强 id 的复杂度，避免被猜测 id 规律
* 做好数据的基础格式校验
* 加强用户权限校验
* 做好热点参数的限流

解决商铺查询的缓存穿透问题:

![image-20251009173834648](./images/image-20251009173834648.png)

代码:

```java
@Override
public Result queryById(Long id) {
    // 1. 从 Redis 查询商铺
    String shopKey = GET_CACHE_SHOP_KEY(id);
    String shopJsonStr = stringRedisTemplate.opsForValue().get(shopKey);

    // 2. Redis 里存在，则直接返回
    if (StrUtil.isNotBlank(shopJsonStr)) {
        Shop shop = JSONUtil.toBean(shopJsonStr, Shop.class);
        return Result.ok(shop);
    }

    // 如果 缓存空对象 则返回错误
    // StrUtil.isBlank(shopJsonStr) 一定为 true，因为 第 2 步里已经判断了 StrUtil.isNotBlank
    if (shopJsonStr != null && StrUtil.isBlank(shopJsonStr)) { 
        // 返回错误
        return Result.fail("【缓存空对象】店铺不存在");
    }

    // 3. Redis 里不存在，则根据 id 查询数据库
    Shop shop = getById(id);

    // 4. 数据库 里不存在，则缓存空值并返回错误
    if (shop == null) {
        // 缓存空字符串，2 分钟过期
        stringRedisTemplate.opsForValue().set(shopKey, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
        // 返回错误
        return Result.fail("店铺不存在");
    }

    // 5. 数据库 里存在，则写入 Redis
    stringRedisTemplate.opsForValue().set(shopKey, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);

    // 6. 返回
    return Result.ok(shop);
}
```

### 2.5. 缓存雪崩

说明:

* 缓存雪崩 是指在同一时间段大量的缓存 key 同时失效 或者 Redis 宕机，导致大量请求到达数据库，带来巨大压力
* 比如，将数据库的大量数据导入到 Redis 时，设置相同的 TTL

解决方案:

* 给不同的 key 的 TTL 添加随机量
* 利用 Redis 集群提高服务的可用性
* 给缓存业务添加降级限流策略（SpringCould）
* 给业务添加多级缓存（SpringCould）

### 2.6. 缓存击穿

说明:

* 缓存击穿问题 也叫做 热点 key 问题
* 就是一个被 **高并发访问** 并且 **缓存重建比较耗时** 的 key 突然失效了，无数的请求访问在瞬间给数据库带来巨大的冲击
* 如下图

![image-20251009185018887](./images/image-20251009185018887.png)

常见解决方案:

* 互斥锁
* 逻辑过期

互斥锁:

![image-20251009185138214](./images/image-20251009185138214.png)

逻辑过期:

![image-20251009185210709](./images/image-20251009185210709.png)

对比:

| 解决方案 | 优点 | 缺点 |
| - | - | - |
| 互斥锁 | 没有额外的内存消耗<br />保证一致性<br />实现简单 | 线程需要等待，性能受影响<br />可能有死锁风险 |
| 逻辑过期 | 线程无需等待，性能较好 | 不保证一致性<br />有额外内存消耗<br />实现复杂 |

#### 2.6.1. 互斥锁 解决缓存击穿的问题

需求:

* 修改 根据 id 查询商铺的业务，基于互斥锁来解决缓存击穿问题

流程:

![image-20251010180650776](./images/image-20251010180650776.png)

互斥锁:

* 基于 Redis 的 setnx（不存在则创建）命令来实现互斥锁
* 获取锁: `setnx lock:shop:商铺ID 1`
   * 成功返回 1
   * 失败返回 0
* 释放锁: `del lock:shop:商铺ID`

代码:

```java
private boolean tryLock(String key) {
    // value 随意
    // TTL 一般是业务处理时间的 10倍 或 20倍
    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);

    // 直接拆箱 Boolean 可能报空指针，建议使用 BooleanUtil
    return BooleanUtil.isTrue(flag);
}

private void unlock(String key) {
    stringRedisTemplate.delete(key);
}

/** 缓存击穿 */
private Shop queryWithMutex(Long id) {
    // 1. 从 Redis 查询商铺
    String shopKey = GET_CACHE_SHOP_KEY(id);
    String shopJsonStr = stringRedisTemplate.opsForValue().get(shopKey);

    // 2. Redis 里存在，则直接返回
    if (StrUtil.isNotBlank(shopJsonStr)) {
        Shop shop = JSONUtil.toBean(shopJsonStr, Shop.class);
        return shop;
    }

    // 如果 缓存空对象 则返回错误
    if (shopJsonStr != null && StrUtil.isBlank(shopJsonStr)) {
        // 返回错误
        return null;
    }

    Shop shop = null;
    String lockKey = "lock:show:" + id;

    try {
        // 3. 实现缓存重建
        // 3.1 获取互斥锁
        boolean isLock = tryLock(lockKey);

        // 3.2 判断是否获取成功
        if (!isLock) {
            // 3.3 获取失败，则休眠并重试
            Thread.sleep(50);

            return queryWithMutex(id);
        }

        // 3.4 再次检查 Redis 是否缓存，避免第二个拿到锁的线程再次 缓存重建

        // 3.5 则根据 id 查询数据库
        shop = getById(id);
        
        // 模拟重建的耗时
        Thread.sleep(200);

        // 4. 数据库 里不存在，则缓存空值并返回错误
        if (shop == null) {
            // 缓存空字符串，2 分钟过期
            stringRedisTemplate.opsForValue().set(shopKey, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            // 返回错误
            return null;
        }

        // 5. 数据库 里存在，则写入 Redis
        stringRedisTemplate.opsForValue().set(shopKey, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    } finally {
        // 6. 释放锁
        unlock(lockKey);
    }
    // 7. 返回
    return shop;
}
```

测试:

* 使用 Apache JMeter 进行测试
* 1000 个线程，5 秒钟，访问 `http://localhost:8081/shop/1`

#### 2.6.2. 逻辑过期 解决缓存击穿的问题

需求:

* 修改 根据 id 查询商铺的业务，基于 逻辑过期 来解决缓存击穿问题

流程:

![image-20251011181353352](./images/image-20251011181353352.png)

难点:

* 逻辑过期时间 字段 放在哪里？
   * 创建 RedisData 组合 过期时间 和 数据
* 缓存预热（如何提前缓存）
   * 在测试代码里添加

代码:

```java
// 使用线程池，避免频繁线程创建与销毁
private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);

/** 解决缓存穿透问题 */
private Shop queryWithLogicExpire(Long id) {
    // 1. 从 Redis 查询商铺
    String shopKey = GET_CACHE_SHOP_KEY(id);
    String redisDataJsonStr = stringRedisTemplate.opsForValue().get(shopKey);

    // 2. Redis 里不存在，则直接返回
    if (StrUtil.isBlank(redisDataJsonStr)) {
        return null;
    }

    // 3. Redis 里存在，则先把 json 反序列化为 RedisData
    RedisData redisData = JSONUtil.toBean(redisDataJsonStr, RedisData.class);
    // Object 类型的属性，hutool 会将其转为 JSONObject 对象
    Object data = redisData.getData();
    JSONObject jsonObjectData = (JSONObject) data;
    // JSONObject 对象 可以继续转为 Shop 对象
    Shop shop = JSONUtil.toBean(jsonObjectData, Shop.class);

    // 4. 判断是否过期
    LocalDateTime expireTime = redisData.getExpireTime();
    boolean isExpired = expireTime.isBefore(LocalDateTime.now());

    if (!isExpired) {
        // 4.1 未过期，直接返回商铺信息
        return shop;
    }

    // 4.2 已过期，则缓存重建

    // 5. 缓存重建
    // 5.1 获取互斥锁
    String lockKey = GET_LOCK_SHOP_KEY(id);
    boolean isAcquiredLock = tryLock(lockKey);

    // 5.2 判断是否获取锁成功
    if (isAcquiredLock) {
        // TODO: 获取锁成功后应该再次检测 Redis 缓存是否过期，做 DoubleCheck，如果存在则无需重建
        // 5.3 成功，则开启独立线程 去缓存重建
        CACHE_REBUILD_EXECUTOR.execute(() -> {
            try {
                this.saveShop2Redis(id, 30L); // 实际应该是 30 分钟
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                // 释放锁
                unlock(lockKey);
            }
        });
    }

    // 5.4 返回过期的商铺信息
    return shop;
}


@Data
public class RedisData {
    private LocalDateTime expireTime;
    private Object data;
}


/** 将数据写入 redis */
public void saveShop2Redis(Long id, Long expireSeconds) {
    // 1. 查询店铺数据
    Shop shop = getById(id);

    // 2. 封装逻辑过期时间
    RedisData redisData = new RedisData();
    redisData.setData(shop);
    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));

    // 3. 写入 Redis
    stringRedisTemplate.opsForValue().set(GET_CACHE_SHOP_KEY(id), JSONUtil.toJsonStr(redisData));
}
```

### 2.7. 缓存工具封装

基于 StringRedisTemplate 封装一个缓存工具类：

* 方法1: 将任意 Java 对象序列化为 json 并存储在 string 类型的 key 中，并且可以设置 TTL 过期时间
* 方法2: 将任意 Java 对象序列化为 json 并存储在 string 类型的 key 中，并且可以设置 逻辑 过期时间，用于处理缓存击穿问题
* 方法3: 根据指定的 key 查询缓存，并反序列化为指定类型，利用缓存空值的方法解决缓存穿透问题
* 方法4: 根据指定的 key 查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题

代码:

```java
@Component
@Slf4j
public class CacheClient {
    private final StringRedisTemplate stringRedisTemplate;

    public CacheClient(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    /** 将任意 Java 对象序列化为 json 并存储在 string 类型的 key 中，并且可以设置 TTL 过期时间 */
    public void set(String key, Object value, Long time, TimeUnit unit) {
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);
    }

    /** 将任意 Java 对象序列化为 json 并存储在 string 类型的 key 中，并且可以设置 逻辑 过期时间，用于处理缓存击穿问题 */
    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) {
        // 设置逻辑过期时间
        RedisData redisData = new RedisData();
        redisData.setData(value);
        // 过期时间 = 当前时间 + TTL
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));

        // 写入 Redis
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));
    }

    /** 根据指定的 key 查询缓存，并反序列化为指定类型，利用缓存空值的方法解决缓存穿透问题 */
    public <R, ID> R queryWithPassThrough(
            String prefix,
            ID id,
            Class<R> type,
            Function<ID, R> dbFallback,
            Long time,
            TimeUnit unit
    ) {
        String key = prefix + id;

        // 1. 从 Redis 查询缓存
        String json = stringRedisTemplate.opsForValue().get(key);

        // 2. 判断是否存在
        if (StrUtil.isNotBlank(json)) {
            // 3. 存在，直接返回
            return JSONUtil.toBean(json, type);
        }

        // 判断命中的 是否 是空值
        if (json != null) { // 不是 null 则为 空字符串("")
            return null;
        }

        // 4. 不存在，则根据 id 查询数据库
        R r = dbFallback.apply(id);

        // 5. 不存在，则返回 null
        if (r == null) {
            // 将 空字符串 写入 Redis
            this.set(key, "", RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);
            // RedisConstants.CACHE_NULL_TTL = 2

            // 返回空
            return null;
        }

        // 6. 存在，则写入 Redis
        this.set(key, JSONUtil.toJsonStr(r), time, unit);

        return r;
    }
    // 使用线程池，避免频繁线程创建与销毁
    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);

    /** 解决缓存穿透问题 */
    public <R, ID> R queryWithLogicExpire(
            String prefix,
            ID id,
            Class<R> type,
            Function<ID, R> dbFallback,
            Long time,
            TimeUnit unit,
            String lockKeyPrefix
    ) {
        // 1. 从 Redis 查询商铺
        String key = prefix + id;
        String redisDataJsonStr = stringRedisTemplate.opsForValue().get(key);

        // 2. Redis 里不存在，则直接返回
        if (StrUtil.isBlank(redisDataJsonStr)) {
            return null;
        }

        // 3. Redis 里存在，则先把 json 反序列化为 RedisData
        RedisData redisData = JSONUtil.toBean(redisDataJsonStr, RedisData.class);
        // Object 类型的属性，hutool 会将其转为 JSONObject 对象
        Object data = redisData.getData();
        JSONObject jsonObjectData = (JSONObject) data;
        // JSONObject 对象 可以继续转为 Shop 对象
        R resultFromRedis = JSONUtil.toBean(jsonObjectData, type);

        // 4. 判断是否过期
        LocalDateTime expireTime = redisData.getExpireTime();
        boolean isExpired = expireTime.isBefore(LocalDateTime.now());

        if (!isExpired) {
            // 4.1 未过期，直接返回商铺信息
            return resultFromRedis;
        }

        // 4.2 已过期，则缓存重建

        // 5. 缓存重建
        // 5.1 获取互斥锁
        String lockKey = lockKeyPrefix + id;
        boolean isAcquiredLock = tryLock(lockKey);

        // 5.2 判断是否获取锁成功
        if (isAcquiredLock) {
            // TODO: 获取锁成功后应该再次检测 Redis 缓存是否过期，做 DoubleCheck，如果存在则无需重建
            // 5.3 成功，则开启独立线程 去缓存重建
            CACHE_REBUILD_EXECUTOR.execute(() -> {
                try {
                    R resultFromDb = dbFallback.apply(id);
                    this.setWithLogicalExpire(key, resultFromDb, time, unit); // 实际应该是 30 分钟
                } catch (Exception e) {
                    throw new RuntimeException(e);
                } finally {
                    unlock(lockKey);
                }
            });
        }

        // 5.4 返回过期的商铺信息
        return resultFromRedis;
    }

    private boolean tryLock(String key) {
        // value 随意
        // TTL 一般是业务处理时间的 10倍 或 20倍
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);

        // 直接拆箱 Boolean 可能报空指针，建议使用 BooleanUtil
        return BooleanUtil.isTrue(flag);
    }

    private void unlock(String key) {
        stringRedisTemplate.delete(key);
    }

}
```

## 3. 优惠券秒杀

目录:

* 全局 ID 生成器
* 实现优惠券秒杀下单
* 超卖问题
* 一人一单
* 分布式锁
* Redis 优化秒杀
* Redis 消息队列实现异步秒杀

### 3.1. 全局 ID 生成器

订单表使用数据库自增 ID 存在问题:

* id 的规律性太明显
* 受单表数据量的限制
   * 每张表都有自己的自增长，拆表后可能存在 id 冲突

全局 ID 生成器：

* 是一种在分布式系统下用来生成全局唯一 ID 的工具
* 特性:
   * 唯一性
   * 高可用
   * 高性能
   * 递增性: 替代数据库自增ID，逐渐变大，有利于数据库索引
   * 安全性: 复杂的递增规则
* Redis 的自增数值满足上述特性

为了增加 ID 的安全性，不直接使用 Redis 自增的数值，而是拼接一些其它信息:

![image-20251031130724836](./images/image-20251031130724836.png)

全局唯一 ID 生成策略:

* UUID: 不是逐渐增大的数字，应用较少
* Redis 自增
* snowflake 算法: 雪花算法，依赖机器的时钟
* 数据库自增: 专门设计一张记录 ID 的表，比 Redis 效率低

Redis 自增 ID 策略:

* 每天一 key，方便统计订单量
* ID 构造: 时间戳 + 技术器

代码:

```java
@Component
public class RedisIdWorker {
    /** 开始时间戳 */
    private static final long BEGIN_TIMESTAMP = 1761868800L;

    /** 序列号的位数 */
    private static final int COUNT_BITS = 32;

    private final StringRedisTemplate stringRedisTemplate;

    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    public long nextId(String keyPrefix) {
        // 1. 生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowEpochSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timestamp = nowEpochSecond - BEGIN_TIMESTAMP;

        // 2. 生成序列号
        // 2.1 获取当前日期，精确到天。方便统计，避免 key 对应的数字超过上限
        String dateStr = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));

        String key = "icr:" + keyPrefix + ":" + dateStr;

        // 2.2 自增长。
        // 如果 key 不存在，则会自动创建并返回 1
        long count = stringRedisTemplate.opsForValue().increment(key);

        // 3. 拼接并返回。
        // 向左移 32 位，空出来的 32 位 0，32 位 0 与 count 进行或运算
        return timestamp << COUNT_BITS | count;
    }

    public static void main(String[] args) {
        // 将 2025-10-31 作为开始日期
        LocalDateTime beginDate = LocalDateTime.of(2025, 10, 31, 0, 0, 0);

        // 计算 beginData 的时间戳
        long beginEpochSeconds = beginDate.toEpochSecond(ZoneOffset.UTC);

        System.out.println("beginEpochSeconds = " + beginEpochSeconds);
        //=> 1761868800
    }
}
```

测试:

```java
@Test
public void testIdWorker() throws InterruptedException {
    int count = 300;

    // 计数器
    CountDownLatch countDownLatch = new CountDownLatch(count);

    // 创建 500 个线程的线程池
    ExecutorService executorService = Executors.newFixedThreadPool(500);

    // 创建一个生成并打印 100 个 ID 的线程任务
    Runnable task = () -> {
        for (int i = 0; i < 100; i++) {
            long id = redisIdWorker.nextId("order");
            System.out.println("id = " + id);
        }
        // 每执行一次，则计数一次
        countDownLatch.countDown();
    };

    long begin = System.currentTimeMillis();

    // 异步执行 300 个线程任务
    for (int i = 0; i < count; i++) {
        executorService.submit(task);
    }

    // 等待计数完毕
    countDownLatch.await();

    long end = System.currentTimeMillis();

    System.out.println("time = " + (end - begin));
}
```

### 3.2. 实现优惠券秒杀下单

需求:

* 平价券 可以任意购买
* 特价券 需要秒杀抢购

表关系:

* tb_voucher: （基本/普通/平价）优惠券的 基本信息、优惠金额、使用规则 等
* tb_seckill_voucher: （秒杀/特价）优惠券的 库存、开始抢购时间、结束抢购时间
   * 相当于继承 tb_voucher

手动新增秒杀券：

```http
POST http://localhost:8081/voucher/seckill
content-type: application/json

{
    "shopId": 1,
    "title": "100元代金券",
    "subTitle": "周一至周五均可使用",
    "rules": "全场通用\\n可无线叠加",
    "payValue": 8000,
    "actualValue": 10000,
    "type": 1,
    "stock": 100,
    "beginTime": "2025-11-01T10:00:00",
    "endTime": "2025-11-01T22:00:00"
}
```

下单时需要判断两点:

* 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单
* 库存是否充足，不足则无法下单

![image-20251101151108861](./images/image-20251101151108861.png)

流程:

1. 查询优惠券
2. 判断秒杀是否开始
3. 判断秒杀是否已经结束
4. 判断库存是否充足
5. 扣减库存
6. 创建订单
7. 返回订单 id

实现:

```java
@Service
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {
    @Resource
    private ISeckillVoucherService seckillVoucherService;

    @Resource
    private RedisIdWorker redisIdWorker;

    @Override
    public Result seckillVoucher(Long voucherId) {
        // 1. 查询优惠券
        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);

        LocalDateTime now = LocalDateTime.now();
        // 2. 判断秒杀是否开始
        if (seckillVoucher.getBeginTime().isAfter(now)) {
            return Result.fail("秒杀未开始");
        }
        // 3. 判断秒杀是否已经结束
        if (seckillVoucher.getEndTime().isBefore(now)) {
            return Result.fail("秒杀已结束");
        }
        // 4. 判断库存是否充足
        if (seckillVoucher.getStock() < 1) {
            return Result.fail("库存不足");
        }
        // 5. 扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1")
                .eq("voucher_id", voucherId)
                .update();

        if (!success) {
            return Result.fail("库存不足");
        }

        // 6. 创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 6.1 订单id
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        // 6.2 用户id
        Long userId = UserHolder.getUser().getId();
        voucherOrder.setUserId(userId);
        // 6.1 代金券id
        voucherOrder.setVoucherId(voucherId);

        save(voucherOrder);

        // 7. 返回订单 id
        return Result.ok(orderId);
    }
}
```