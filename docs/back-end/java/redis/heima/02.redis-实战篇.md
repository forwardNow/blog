<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2025-09-19 16:48:39
@modify date 2025-10-10 19:01:13
@desc [description]
#endregion-->


# redis-实战篇

目录:

* 短信登录

   * Redis 的共享 session 应用

* 商户查询缓存

   * 企业的缓存使用技巧
   * 解决 缓存雪崩、穿透 等问题

* 优惠券秒杀

   * Redis 的计数器、Lua 脚本 Redis
   * 分布式锁
   * Redis 的三种消息队列

* 达人探店

   * 基于 List 的点赞列表
   * 基于 SortedSet 的点赞排行榜

* 好友关注

   * 基于 Set 集合的关注、取关、共同关注
   * 消息推送等功能

* 附近的商户

   * Redis 的 GeoHash 的应用
   
* 用户签到

   * Redis 的 BitMap 数据统计功能

* UV统计

   * Redis 的 HyperLogLog 的统计功能

## 1. 短信登录

### 1.1. 导入黑马点评项目

表:

* tb_user: 用户
* tb_user_info: 用户详情 
* tb_shop: 商户信息
* tb_shop_type: 商户类型
* tb_blog: 用户日记
* tb_follow: 用户关注
* tb_voucher: 优惠券
* tb_voucher_order: 优惠券的订单

架构:

![image-20250928122620186](./images/image-20250928122620186.png)

测试:

* 服务端: http://localhost:8081/api/shop-type/list
* 客户端: http://localhost:8080 (移动端Web模式)
   * 启动 Ngxin: `start nginx.exe` (CMD)

### 1.2. 基于 Session 实现登录

#### 1.2.1. 流程

![image-20250928214129757](./images/image-20250928214129757.png)

#### 1.2.2. 发送验证码

```java
@Service
@Slf4j
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {

    @Override
    public Result sendCode(String phone, HttpSession session) {
        // 1. 校验手机号
        boolean phoneInvalid = RegexUtils.isPhoneInvalid(phone);

        // 2. 如果校验失败，则返回错误信息
        if (phoneInvalid) {
            return Result.fail("手机号格式错误");
        }

        // 3. 校验成功，生成验证码 (cn.hutool.core.util.RandomUtil)
        String code = RandomUtil.randomNumbers(6);

        // 4. 保存验证码到 session
        session.setAttribute("code", code);

        // 5. 发送验证码到手机 (直接在控制台打印)
        log.debug("发送验证码成功，验证码为: {}", code);

        // 返回 成功
        return Result.ok();
    }
}
```

#### 1.2.3. 短信验证码登录和注册

```java
@Override
public Result login(LoginFormDTO loginForm, HttpSession session) {
   String phone = loginForm.getPhone();

   // 1. 校验手机号
   boolean phoneInvalid = RegexUtils.isPhoneInvalid(phone);
   // 1.1 如果校验失败，则返回错误信息
   if (phoneInvalid) {
      return Result.fail("手机号格式错误");
   }

   // 2. 校验验证码
   String code = loginForm.getCode();
   Object cachedCode = session.getAttribute("code");

   // 2.1 不一致，报错
   if (cachedCode == null || !cachedCode.toString().equals(code)) {
      return Result.fail("验证码错误");
   }

   // 3. 根据手机号查询用户
//        User user = lambdaQuery().eq(User::getPhone, phone).one(); // ?? 为什么不可以
   User user = query().eq("phone", phone).one();

   // 4. 用户不存在则创建
   if (user == null) {
      user = createUserWithPhone(phone);
   }

   // 5. 保存用户信息到 session
   session.setAttribute("user", user);

   return Result.ok();
}

private User createUserWithPhone(String phone) {
   User user = new User();

   user.setPhone(phone);
   user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(6));

   save(user);

   return user;
}
```

#### 1.2.4. 登录校验拦截器

UserHolder:

```java
public class UserHolder {
    private static final ThreadLocal<User> tl = new ThreadLocal<>();

    public static void saveUser(User user){
        tl.set(user);
    }

    public static User getUser(){
        return tl.get();
    }

    public static void removeUser(){
        tl.remove();
    }
}
```

拦截器: 

```java
/**
 * 每个请求处理之前 都判断 session 中是否有 user,
 *    有 则 存入 ThreadLocal，供后续方法进行处理，并放行
 *    无 则 返回 401，不放行
 * 请求处理完毕，则销毁掉 ThreadLocal 中的 User
 */
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 获取 session
        HttpSession session = request.getSession();

        // 2. 获取 session 中的用户
        Object user = session.getAttribute("user");

        // 3. 用户不存在，拦截 并返回 401 或抛异常
        if (user == null) {
            log.info("用户不存在");
            response.setStatus(401);
            return false;
        }

        // 4. 用户存在，存入 ThreadLocal
        UserHolder.saveUser((User) user);

        // 5. 放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        UserHolder.removeUser();
    }
}
```

注册拦截器:

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry
                .addInterceptor(new LoginInterceptor())
                // 排除（不拦截）
                .excludePathPatterns(
                        "/shop/**",
                        "/shop-type/**",
                        "/voucher/**",
                        "/upload/**",
                        "/blog/hot",

                        "/user/code",
                        "/user/login"
                );
    }
}
```

#### 1.2.5. 隐藏用户敏感信息

说明:

* 接口返回的 User 是一个完整的对象，包含用户所有的信息，其中有很多敏感的数据
* ThreadLocal 里存储的 User 越小越好

### 1.3. 集群的 Session 共享问题

![image-20250930085621764](./images/image-20250930085621764.png)

session 共享问题:

* 多台 Tomcat 并不共享 session 存储空间，当请求切换到不同 Tomcat 服务时导致数据丢失的问题

session 的替代方案应该满足:

* 数据共享
* 内存存储
* key、value 结构

### 1.4. 基于 Redis 实现共享 Session 登录

#### 1.4.1. Redis 代替 session 的业务流程

发送短信验证码:

![image-20250930122127850](./images/image-20250930122127850.png)

短信验证码登录、注册:

![image-20250930122137450](./images/image-20250930122137450.png)

校验登录状态:

![image-20250930122142215](./images/image-20250930122142215.png)


#### 1.4.2. 发送短信验证码

```java
public class RedisConstants {
    public static final String LOGIN_CODE_KEY = "login:code:";
    public static final Long LOGIN_CODE_TTL = 2L;
}

// ...

@Autowired
private StringRedisTemplate stringRedisTemplate;

// 4. 保存验证码到 redis
stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + "phone", code, LOGIN_CODE_TTL, TimeUnit.MINUTES);
```

#### 1.4.3. 短信验证码登录、注册

```java
@Override
public Result login(LoginFormDTO loginForm, HttpSession session) {
   String phone = loginForm.getPhone();

   // 1. 校验手机号
   boolean phoneInvalid = RegexUtils.isPhoneInvalid(phone);
   // 1.1 如果校验失败，则返回错误信息
   if (phoneInvalid) {
      return Result.fail("手机号格式错误");
   }

   // 2. 校验验证码
   String code = loginForm.getCode();
   String cachedCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);

   // 2.1 不一致，报错
   if (cachedCode == null || !cachedCode.equals(code)) {
      return Result.fail("验证码错误");
   }

   // 3. 根据手机号查询用户
   User user = query().eq("phone", phone).one();

   // 4. 用户不存在则创建
   if (user == null) {
      user = createUserWithPhone(phone);
   }

   // 5. 保存用户信息到 redis

   // 5.1 生成随机 token (uuid)
   String token = UUID.randomUUID().toString(true); // true - 不带中划线的 UUID

   // 5.2 将 user 转 Map
   UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);

   // stringRedisTemplate 要求 Hash 值中的 value 必须为 String
   CopyOptions copyOptions = CopyOptions.create()
            .setIgnoreNullValue(true)
            .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString());
   Map<String, Object> userMap = BeanUtil.beanToMap(userDTO, new HashMap<>(), copyOptions);

   // 5.3 将 userMap 存储到 Redis
   String tokenKey = LOGIN_USER_KEY + token;
   stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);

   // 5.4 设置 token 有效期
   stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);

   // 6. 将 token 返回给前端
   return Result.ok(token);
}
```

#### 1.4.4. 校验登录状态

```java
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {
    private final StringRedisTemplate stringRedisTemplate;

    public LoginInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 获取请求头中 token
        String token = request.getHeader("authorization");

        // 1.1 不能存在，则返回 401
        if (StrUtil.isEmpty(token)) {
            log.info("未携带自定义请求头: authorization=token");
            response.setStatus(401);
            return false;
        }

        // 2. 基于 token 获取 Redis 中存储的 user
        String tokenKey = RedisConstants.LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(tokenKey);

        // 3. 用户不存在，拦截 并返回 401 或抛异常
        if (CollectionUtil.isEmpty(userMap)) {
            log.info("用户不存在");
            response.setStatus(401);
            return false;
        }

        // 4. 用户存在，存入 ThreadLocal
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);
        UserHolder.saveUser(userDTO);

        // 5. 刷新 token 有效期
        stringRedisTemplate.expire(tokenKey, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);

        // 6. 放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        UserHolder.removeUser();
    }
}
```

### 1.5. 优化登录拦截器

说明:

* 登录拦截器，拦截 非匿名 请求，校验用户是否登录（ThreadLocal 中是否有 user）
* token 刷新拦截器，拦截所有请求，校验 token 并将 user 保存到 ThreadLocal

![image-20251001111832362](./images/image-20251001111832362.png)

代码:

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Resource
    private StringRedisTemplate stringRedisTemplate;

    // 注册拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate))
                // 拦截器的顺序默认为 0 （越小优先级高），相同则先添加的先执行
                .order(0)
                // 默认就是拦截所有
                .addPathPatterns("/**");

        registry
                .addInterceptor(new LoginInterceptor())
                .order(1)
                // 排除（不拦截）
                .excludePathPatterns(
                        "/shop/**",
                        "/shop-type/**",
                        "/voucher/**",
                        "/upload/**",
                        "/blog/hot",

                        "/user/code",
                        "/user/login"
                );

    }
}

// 刷新 token 拦截器
@Slf4j
public class RefreshTokenInterceptor implements HandlerInterceptor {
    private final StringRedisTemplate stringRedisTemplate;

    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 获取请求头中 token
        String token = request.getHeader("authorization");

        // 1.1 不存在，直接放行 并 返回
        if (StrUtil.isEmpty(token)) {
            log.info("token 为空");
            return true;
        }

        // 2. 基于 token 获取 Redis 中存储的 user
        String tokenKey = RedisConstants.LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(tokenKey);

        // 3. 用户不存在，直接放行 并 返回
        if (CollectionUtil.isEmpty(userMap)) {
            log.info("用户不存在");
            return true;
        }

        // 4. 用户存在，存入 ThreadLocal
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);
        UserHolder.saveUser(userDTO);

        // 5. 刷新 token 有效期
        stringRedisTemplate.expire(tokenKey, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);

        // 6. 放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        UserHolder.removeUser();
    }
}

// 登录拦截器
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 判断 ThreadLocal 中是否有 user，无则返回 401
        if (UserHolder.getUser() == null) {
            log.info("未登录");
            response.setStatus(401);
            return false;
        }
        return true;
    }
}
```

## 2. 商户查询缓存

目录:

* 什么是缓存
* 添加 Redis 缓存
* 缓存更新策略
* 缓存穿透
* 缓存雪崩
* 缓存击穿
* 缓存工具封装

### 2.1. 什么是缓存

缓存:

* 缓存就是数据交换的缓冲区（cache）
* 是存储数据的临时地方，一般读写性能较高

作用:

* 降低后端负载
* 提高读写效率，减少响应时间

成本:

* 数据一致性成本
* 代码维护成本
* 运维成本

### 2.2. 添加 Redis 缓存

功能：

* 添加商户缓存

流程:

1. 从 Redis 查询商铺
2. Redis 里存在，则直接返回
3. Redis 里不存在，则根据 id 查询数据库
4. 数据库 里不存在，返回错误
5. 数据库 里存在，则写入 Redis
6. 返回

### 2.3. 缓存更新策略

策略:

| 策略 | 内存淘汰 | 超时剔除 | 主动更新 |
| - | - | - | - |
| 说明 | 不用自己维护，利用 Redis 的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存 | 给缓存数据添加 TTL 时间，到期后自动删除缓存。下次查询时更新缓存 | 编写业务逻辑，在修改数据库的同时，更新缓存 |
| 一致性 | 差 | 一般 | 好 |
| 维护成本 | 无 | 低 | 高 |

业务场景:

* 低一致性需求: 使用内存淘汰机制。例如 店铺类型 的查询缓存。
* 高一致性需求: 主动更新，并以超时剔除作为兜底方案。例如 店铺详情 的查询缓存

主动更新策略:

* 【√】Cache Aside Pattern 
   * 由缓存的调用者，在更新数据库的同时更新缓存 【主动更新】
* Read/Write Through Pattern
   * 缓存与数据库整合为一个服务，由服务来维护一致性
   * 调用者调用该服务，无需关心缓存一致性问题
* Write Behind Caching Pattern
   * 调用者只操作缓存
   * 由其它线程异步的将缓存数据持久化到数据库，保证最终一致性

主动更新 需要考虑如下问题:

1. 删除缓存还是更新缓存?

   * 更新缓存: 每次更新数据库都更新缓存，无效写操作较多【×】
   * 删除缓存: 更新数据库时让缓存失效，查询时再更新缓存【√】
   
2. 如何保证缓存与数据库的操作 同时成功或失败【事务问题】

   * 单体系统: 将缓存与数据库操作放在同一个事物
   * 分布式系统: 利用 TCC 等分布式事务方案

3. 先操作 缓存 还是先操作 数据库？【线程安全问题】

   * 先删除缓存，再操作数据库【×】
   * 先操作数据库，再删除缓存【√】


分析 “先操作 缓存 还是先操作 数据库”：

![image-20251003175217574](./images/image-20251003175217574.png)

最佳实践:

1. 低一致性需求: 使用 Redis 自带的内存淘汰机制
2. 高一致性需求: 主动更新，并以超时剔除作为兜底方案
   * 读操作
      * 缓存命中则直接返回
      * 缓存未命中则查询数据库，并写入缓存，设定超时时间
   * 写操作
      * 先写数据库，然后再删除缓存
      * 要确保数据库与缓存操作的原子性

案例: 修改 ShopController 中的业务逻辑，满足如下需求

* 根据 ID 查询店铺时，如果换成未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间
* 根据 ID 修改店铺时，先修改数据库，再删除缓存

```java
@Transactional
@Override
public Result update(Shop shop) {
    Long id = shop.getId();

    if (id == null) {
        return Result.fail("店铺ID不能为空");
    }

    // 1. 先修改数据库
    updateById(shop);

    // 2. 再修改Redis
    stringRedisTemplate.delete(GET_CACHE_SHOP_KEY(id));

    return Result.ok();
}
```

### 2.4. 缓存穿透

说明:

* 缓存穿透 是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会到达数据库
* 不断发起这样的请求，会给数据库带来巨大的压力

常见解决方案:

* 缓存空对象【√】
* 布隆过滤

缓存空对象:

* 优点: 实现简单，维护方便
* 缺点: 额外的内存消耗；可能造成短期的不一致

![image-20251009124941399](./images/image-20251009124941399.png)

布隆过滤:

* 优点: 内存占用较少，没有多余 key
* 缺点: 实现复杂; 存在误判的可能

![image-20251009124949395](./images/image-20251009124949395.png)

其他主动方案: （该讲师的 SpringCould 课程里有讲）

* 增强 id 的复杂度，避免被猜测 id 规律
* 做好数据的基础格式校验
* 加强用户权限校验
* 做好热点参数的限流

解决商铺查询的缓存穿透问题:

![image-20251009173834648](./images/image-20251009173834648.png)

代码:

```java
@Override
public Result queryById(Long id) {
    // 1. 从 Redis 查询商铺
    String shopKey = GET_CACHE_SHOP_KEY(id);
    String shopJsonStr = stringRedisTemplate.opsForValue().get(shopKey);

    // 2. Redis 里存在，则直接返回
    if (StrUtil.isNotBlank(shopJsonStr)) {
        Shop shop = JSONUtil.toBean(shopJsonStr, Shop.class);
        return Result.ok(shop);
    }

    // 如果 缓存空对象 则返回错误
    // StrUtil.isBlank(shopJsonStr) 一定为 true，因为 第 2 步里已经判断了 StrUtil.isNotBlank
    if (shopJsonStr != null && StrUtil.isBlank(shopJsonStr)) { 
        // 返回错误
        return Result.fail("【缓存空对象】店铺不存在");
    }

    // 3. Redis 里不存在，则根据 id 查询数据库
    Shop shop = getById(id);

    // 4. 数据库 里不存在，则缓存空值并返回错误
    if (shop == null) {
        // 缓存空字符串，2 分钟过期
        stringRedisTemplate.opsForValue().set(shopKey, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
        // 返回错误
        return Result.fail("店铺不存在");
    }

    // 5. 数据库 里存在，则写入 Redis
    stringRedisTemplate.opsForValue().set(shopKey, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);

    // 6. 返回
    return Result.ok(shop);
}
```

### 2.5. 缓存雪崩

说明:

* 缓存雪崩 是指在同一时间段大量的缓存 key 同时失效 或者 Redis 宕机，导致大量请求到达数据库，带来巨大压力
* 比如，将数据库的大量数据导入到 Redis 时，设置相同的 TTL

解决方案:

* 给不同的 key 的 TTL 添加随机量
* 利用 Redis 集群提高服务的可用性
* 给缓存业务添加降级限流策略（SpringCould）
* 给业务添加多级缓存（SpringCould）

### 2.6. 缓存击穿

说明:

* 缓存击穿问题 也叫做 热点 key 问题
* 就是一个被 **高并发访问** 并且 **缓存重建比较耗时** 的 key 突然失效了，无数的请求访问在瞬间给数据库带来巨大的冲击
* 如下图

![image-20251009185018887](./images/image-20251009185018887.png)

常见解决方案:

* 互斥锁
* 逻辑过期

互斥锁:

![image-20251009185138214](./images/image-20251009185138214.png)

逻辑过期:

![image-20251009185210709](./images/image-20251009185210709.png)

对比:

| 解决方案 | 优点 | 缺点 |
| - | - | - |
| 互斥锁 | 没有额外的内存消耗<br />保证一致性<br />实现简单 | 线程需要等待，性能受影响<br />可能有死锁风险 |
| 逻辑过期 | 线程无需等待，性能较好 | 不保证一致性<br />有额外内存消耗<br />实现复杂 |

#### 2.6.1. 互斥锁 解决缓存击穿的问题

需求:

* 修改 根据 id 查询商铺的业务，基于互斥锁来解决缓存击穿问题

流程:

![image-20251010180650776](./images/image-20251010180650776.png)

互斥锁:

* 基于 Redis 的 setnx（不存在则创建）命令来实现互斥锁
* 获取锁: `setnx lock:shop:商铺ID 1`
   * 成功返回 1
   * 失败返回 0
* 释放锁: `del lock:shop:商铺ID`

代码:

```java
private boolean tryLock(String key) {
    // value 随意
    // TTL 一般是业务处理时间的 10倍 或 20倍
    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);

    // 直接拆箱 Boolean 可能报空指针，建议使用 BooleanUtil
    return BooleanUtil.isTrue(flag);
}

private void unlock(String key) {
    stringRedisTemplate.delete(key);
}

/** 缓存击穿 */
private Shop queryWithMutex(Long id) {
    // 1. 从 Redis 查询商铺
    String shopKey = GET_CACHE_SHOP_KEY(id);
    String shopJsonStr = stringRedisTemplate.opsForValue().get(shopKey);

    // 2. Redis 里存在，则直接返回
    if (StrUtil.isNotBlank(shopJsonStr)) {
        Shop shop = JSONUtil.toBean(shopJsonStr, Shop.class);
        return shop;
    }

    // 如果 缓存空对象 则返回错误
    if (shopJsonStr != null && StrUtil.isBlank(shopJsonStr)) {
        // 返回错误
        return null;
    }

    Shop shop = null;
    String lockKey = "lock:show:" + id;

    try {
        // 3. 实现缓存重建
        // 3.1 获取互斥锁
        boolean isLock = tryLock(lockKey);

        // 3.2 判断是否获取成功
        if (!isLock) {
            // 3.3 获取失败，则休眠并重试
            Thread.sleep(50);

            return queryWithMutex(id);
        }

        // 3.4 再次检查 Redis 是否缓存，避免第二个拿到锁的线程再次 缓存重建

        // 3.5 则根据 id 查询数据库
        shop = getById(id);
        
        // 模拟重建的耗时
        Thread.sleep(200);

        // 4. 数据库 里不存在，则缓存空值并返回错误
        if (shop == null) {
            // 缓存空字符串，2 分钟过期
            stringRedisTemplate.opsForValue().set(shopKey, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            // 返回错误
            return null;
        }

        // 5. 数据库 里存在，则写入 Redis
        stringRedisTemplate.opsForValue().set(shopKey, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    } finally {
        // 6. 释放锁
        unlock(lockKey);
    }
    // 7. 返回
    return shop;
}
```

测试:

* 使用 Apache JMeter 进行测试
* 1000 个线程，5 秒钟，访问 `http://localhost:8081/shop/1`

#### 逻辑过期 解决缓存击穿的问题