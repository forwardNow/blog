<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2026-02-04 17:03:58
@modify date 2026-02-14 18:34:57
@desc [description]
#endregion-->

# SpringCloud-黑马-教程

## 1. 微服务技术栈导学

微服务技术栈:

![image-20260213221822203](./images/image-20260213221822203.png)

实用篇:

1. 微服务治理
   * Eureka
   * Nacos
   * OpenFeign
   * 网关 Gateway
   * 配置中心 Nacos
   
2. Docker
   * Docker 原理
   * Docker 使用
   * Dockerfile
   * DockerCompose

3. 异步通信
   * 同步和异步
   * MQ技术选型
   * SpringAMQP
   * 消费者限流

4. 分布式搜索
   * DSL 语法
   * HighLevelClient
   * 拼音搜索
   * 自动补全
   * 竞价排名
   * 地理搜索
   * 聚合统计
   * 分片集群

高级篇:

1. 微服务保护
   * 流量控制
   * 系统保护
   * 熔断降级
   * 服务授权

2. 分布式事务
   * XA 模式
   * TCC 模式
   * AT 模式
   * Saga 模式

3. 分布式缓存
   * 数据持久化
   * Redis 主从集群
   * 哨兵机制
   * Redis 分片集群

4. 多级缓存
   * 多级缓存分层
   * Nginx 缓存
   * Redis 缓存
   * Canal 数据同步

5. 可靠消息服务
   * 消息三方确认
   * 惰性队列
   * 延迟队列
   * 镜像集群
   * 仲裁队列

面试篇:

1. Nacos 源码
   * Nacos 的服务发现原理
   * Nacos 服务注册原理
   * Nacos 心跳机制
   * Nacos、Eureka 差异

2. Sentinel 源码
   * Sentinel 滑动窗口算法
   * 令牌桶算法
   * 漏桶算法

3. Redis 热点问题
   * 分布式锁问题
   * 缓存穿透
   * 缓存击穿
   * 缓存雪崩

## 2. 认识微服务

### 2.1. 服务架构演变

#### 2.1.1. 单体架构

单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。

![image-20260214094539190](./images/image-20260214094539190.png)

优点：

* 架构简单
* 部署成本低

缺点：

* 耦合度高

#### 2.1.2. 分布式架构

分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。

![image-20260214101008818](./images/image-20260214101008818.png)

优点：

* 降低服务耦合
* 有利于服务升级拓展

#### 2.1.3. 服务治理

![image-20260214101117827](./images/image-20260214101117827.png)

分布式架构的要考虑的问题：

* 服务拆分粒度如何？
* 服务集群地址如何维护？
* 服务之间如何实现远程调用？
* 服务健康状态如何感知？

#### 2.1.4. 微服务

![image-20260214101302417](./images/image-20260214101302417.png)

微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征：

* 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发
* 面向服务：微服务对外暴露业务接口
* 自治：团队独立、技术独立、数据独立、部署独立
* 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题

#### 2.1.5. 小结

单体架构特点？

* 简单方便，高度耦合，扩展性差。
* 适合小型项目，例如：学生管理系统

分布式架构特点？

* 松耦合，扩展性好，但架构复杂，难度大。
* 适合大型互联网项目，例如：京东、淘宝

微服务：一种良好的分布式架构方案

* 优点：拆分粒度更小、服务更独立、耦合度更低
* 缺点：架构非常复杂，运维、监控、部署难度提高


### 2.2. 微服务技术对比

#### 2.2.1. 微服务结构

微服务这种方案需要技术框架来落地，全球的互联网公司都在积极尝试自己的微服务落地技术。在国内最知名的就是 SpringCloud 和阿里巴巴的 Dubbo。

![image-20260214103136602](./images/image-20260214103136602.png)

#### 2.2.2. 微服务技术对比

|                | Dubbo               | SpringCloud              | SpringCloudAlibaba       |
| -------------- | ------------------- | ------------------------ | ------------------------ |
| 注册中心       | zookeeper、Redis    | Eureka、Consul           | Nacos、Eureka            |
| 服务远程调用   | Dubbo协议           | Feign（http协议）        | Dubbo、Feign             |
| 配置中心       | 无                  | SpringCloudConfig        | SpringCloudConfig、Nacos |
| 服务网关       | 无                  | SpringCloudGateway、Zuul | SpringCloudGateway、Zuul |
| 服务监控和保护 | dubbo-admin，功能弱 | Hystix                   | Sentinel                 |

#### 2.2.3. 企业需求

SpringCloud + Feign:

* 使用SpringCloud技术栈
* 服务接口采用Restful风格
* 服务调用采用Feign方式

SpringCloudAlibaba + Feign:

* 使用SpringCloudAlibaba技术栈
* 服务接口采用Restful风格
* 服务调用采用Feign方式

SpringCloudAlibaba + Dubbo:

* 使用SpringCloudAlibaba技术栈
* 服务接口采用Dubbo协议标准
* 服务调用采用Dubbo方式

Dubbo 原始模式:

* 基于Dubbo老旧技术体系
* 服务接口采用Dubbo协议标准
* 服务调用采用Dubbo方式

### 2.3. SpringCloud

SpringCloud是目前国内使用最广泛的微服务框架。

官网地址：https://spring.io/projects/spring-cloud 。

SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验:

* 服务注册发现: Eureka, Nacos, Consul
* 服务远程调用: OpenFeign、 Dubbo
* 服务链路监控: Zipkin、 Sleuth
* 统一配置管理: SpringCloudConfig、 Nacos
* 统一网关路由: SpringCloudGateway、 Zuul
* 流控、降级、保护: Hystix, Sentinel

SpringCloud 与 SpringBoot 的版本兼容关系如下：

| Release Train | Spring Boot Generation |
| - | - |
| 2025.1.x aka Oakwood | 4.0.x |
| 2025.0.x aka Northfields | 3.5.x |
| 2024.0.x aka Moorgate | 3.4.x |
| 2023.0.x aka Leyton | 3.3.x, 3.2.x |
| 2022.0.x aka Kilburn | 3.0.x, 3.1.x (Starting with 2022.0.3) |
| 2021.0.x aka Jubilee | 2.6.x, 2.7.x (Starting with 2021.0.3) |
| 2020.0.x aka Ilford | 2.4.x, 2.5.x (Starting with 2020.0.3) |
| Hoxton | 2.2.x, 2.3.x (Starting with SR5) |

本教程的 SpringCloud 版本是 Hoxton.SR10，因此对应的 SpringBoot 版本是 2.3.x 版本。

## 3. 服务拆分及远程调用

### 3.1. 服务拆分

服务拆分注意事项:

* 单一职责：不同微服务，不要重复开发相同业务
* 数据独立：不要访问其它微服务的数据库
* 面向服务：将自己的业务暴露为接口，供其它微服务调用

项目结构:

```text
cloud-demo/          # 父工程
   order-service/       # 子项目
      根据 ID 查询订单
   user-service/        # 子项目
      根据 ID 查询用户
```

order-service 项目的数据库的脚本:

```sql
DROP DATABASE IF EXISTS cloud_order;
CREATE DATABASE cloud_order;
USE cloud_order;

DROP TABLE IF EXISTS `tb_order`;
CREATE TABLE `tb_order`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '订单id',
  `user_id` bigint(20) NOT NULL COMMENT '用户id',
  `name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '商品名称',
  `price` bigint(20) NOT NULL COMMENT '商品价格',
  `num` int(10) NULL DEFAULT 0 COMMENT '商品数量',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 109 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

INSERT INTO `tb_order` VALUES (101, 1, 'Apple 苹果 iPhone 12 ', 699900, 1);
INSERT INTO `tb_order` VALUES (102, 2, '雅迪 yadea 新国标电动车', 209900, 1);
INSERT INTO `tb_order` VALUES (103, 3, '骆驼（CAMEL）休闲运动鞋女', 43900, 1);
INSERT INTO `tb_order` VALUES (104, 4, '小米10 双模5G 骁龙865', 359900, 1);
INSERT INTO `tb_order` VALUES (105, 5, 'OPPO Reno3 Pro 双模5G 视频双防抖', 299900, 1);
INSERT INTO `tb_order` VALUES (106, 6, '美的（Midea) 新能效 冷静星II ', 544900, 1);
INSERT INTO `tb_order` VALUES (107, 2, '西昊/SIHOO 人体工学电脑椅子', 79900, 1);
INSERT INTO `tb_order` VALUES (108, 3, '梵班（FAMDBANN）休闲男鞋', 31900, 1);
```

user-service 项目的数据库的脚本: 

```sql
DROP DATABASE IF EXISTS cloud_user;
CREATE DATABASE cloud_user;
USE cloud_user;

DROP TABLE IF EXISTS `tb_user`;
CREATE TABLE `tb_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '收件人',
  `address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '地址',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 109 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

INSERT INTO `tb_user` VALUES (1, '柳岩', '湖南省衡阳市');
INSERT INTO `tb_user` VALUES (2, '文二狗', '陕西省西安市');
INSERT INTO `tb_user` VALUES (3, '华沉鱼', '湖北省十堰市');
INSERT INTO `tb_user` VALUES (4, '张必沉', '天津市');
INSERT INTO `tb_user` VALUES (5, '郑爽爽', '辽宁省沈阳市大东区');
INSERT INTO `tb_user` VALUES (6, '范兵兵', '山东省青岛市');
```

访问:

* http://localhost:8081/user/1
* http://localhost:8080/order/101

小结:

* 微服务需要根据业务模块拆分，做到单一职责,不要重复开发相同业务
* 微服务可以将业务暴露为接口，供其它微服务使用
* 不同微服务都应该有自己独立的数据库

### 3.2. 服务间调用

需求：根据订单id查询订单的同时，把订单所属的用户信息一起返回

分析:

* 在 order-service 服务里，向 user-service 发送 HTTP 请求，获取用户信息，合并后返回给用户

使用 RestTemplate 发送 HTTP 请求

步骤 1. 在启动类里注册 RestTemplate

```java
@SpringBootApplication
public class OrderApplication {

 // ...
 
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

步骤 2. 修改订单服务

```java
@Service
public class OrderService {

    @Autowired
    private OrderMapper orderMapper;

    @Autowired
    private RestTemplate restTemplate;

    public Order queryOrderById(Long orderId) {
        // 1.查询订单
        Order order = orderMapper.findById(orderId);

        // 2. 发送请求获取用户
        String url = "http://localhost:8081/user/" + order.getUserId();
        User user = restTemplate.getForObject(url, User.class);

        // 3. 将用户塞入订单对象
        order.setUser(user);

        // 4.返回
        return order;
    }
}
```

小结:

* 微服务调用方式
   * 基于RestTemplate发起的http请求实现远程调用
   * http 请求做远程调用是与语言无关的调用，只要知道对方的 ip、端口、接口路径、请求参数 即可。

### 3.3. 提供者与消费者

服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）

服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）

服务 A 调用服务 B，服务 B 调用服务 C，那么服务 B 是什么角色？

服务调用关系:

* 服务提供者：暴露接口给其它微服务调用
* 服务消费者：调用其它微服务提供的接口
* 提供者与消费者角色其实是相对的
* 一个服务可以同时是服务提供者和服务消费者

## 4. Eureka 注册中心

`[juˈriːkə]`

### 4.1. 远程调用的问题

服务调用出现的问题:

* 服务消费者该如何获取服务提供者的地址信息？
* 如果有多个服务提供者，消费者该如何选择？
* 消费者如何得知服务提供者的健康状态？

### 4.2. eureka 原理

Eureka 的作用:

![2026-02-14_144636](./images/2026-02-14_144636.png)

消费者该如何获取服务提供者具体信息？

* 服务提供者启动时向eureka注册自己的信息
* eureka保存这些信息
* 消费者根据服务名称向eureka拉取提供者信息

如果有多个服务提供者，消费者该如何选择？

* 服务消费者利用负载均衡算法，从服务列表中挑选一个

消费者如何感知服务提供者健康状态？

* 服务提供者会每隔 30 秒向 EurekaServer 发送心跳请求，报告健康状态
* eureka 会更新记录服务列表信息，心跳不正常会被剔除
* 消费者就可以拉取到最新的信息

在 Eureka 架构中，微服务角色有两类：

EurekaServer：服务端，注册中心

* 记录服务信息
* 心跳监控

EurekaClient：客户端

* Provider：服务提供者，例如案例中的 user-service
   * 注册自己的信息到EurekaServer
   * 每隔30秒向EurekaServer发送心跳
* Consumer：服务消费者，例如案例中的 order-service
   * 根据服务名称从 EurekaServer 拉取服务列表
   * 基于服务列表做负载均衡，选中一个微服务后发起远程调用

### 4.3. 搭建 EurekaServer

#### 4.3.1. 动手实践

1. 搭建注册中心
   * 搭建EurekaServer

2. 服务注册
   * 将 user-service、order-service 都注册到 eureka

3. 服务发现
   * 在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用

#### 4.3.2. 搭建 EurekaServer

步骤 1. 创建项目，引入 spring-cloud-starter-netflix-eureka-server 的依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
```

步骤 2. 编写启动类，添加 @EnableEurekaServer 注解

```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaApplication {
    public static void main( String[] args ) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
```

步骤 3. 添加 application.yml 文件，编写下面的配置：

```yml
server:
  port: 10086
spring:
  application:
    name: eurekaserver # eureka 的服务名称
eureka:
  client:
    service-url: # eureka 的地址信息
      defaultZone: http://127.0.0.1:10086/eureka
```

访问: http://localhost:10086/


### 4.4. 服务注册

将 user-service 服务注册到 EurekaServer 步骤如下：

步骤 1. 加 eureka-client 的依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

步骤 2. 配置 eureka 的地址

```yml
spring:
  application:
    name: userservice # user 的服务名称

eureka:
  client:
    service-url: # eureka 的地址信息
      defaultZone: http://127.0.0.1:10086/eureka
```

小结:

* 服务注册
   * 引入 eureka-client 依赖
   * 在 application.yml 中配置 eureka 地址
* 无论是消费者还是提供者，引入 eureka-client 依赖、知道 eureka 地址后，都可以完成服务注册

### 4.5. 服务发现

服务拉取是基于服务名称获取服务列表，然后在对服务列表做负载均衡

修改 OrderService 的代码，修改访问的 url 路径，用服务名代替 ip、端口：

```java
// String url = "http://localhost:8081/user/" + order.getUserId();
String url = "http://userservice/user/" + order.getUserId();
```

在 order-service 项目的启动类 OrderApplication 中的 RestTemplate 添加负载均衡注解:

```java
@LoadBalanced // 负载均衡注解
@Bean
public RestTemplate restTemplate() {
   return new RestTemplate();
}
```

### 4.6. 小结

搭建 EurekaServer:

* 引入eureka-server依赖
* 添加@EnableEurekaServer注解
* 在application.yml中配置eureka地址

服务注册:

* 引入 eureka-client 依赖
* 在 application.yml 中配置 eureka 地址

服务发现:

* 引入 eureka-client 依赖
* 在 application.yml 中配置 eureka 地址
* 给 RestTemplate 添加 @LoadBalanced 注解
* 用服务提供者的服务名称远程调用

## 5. Ribbon 负载均衡原理

## 6. Nacos 注册中心