<!--#region
@author 吴钦飞
@email wuqinfei@qq.com
@create date 2025-11-22 16:07:23
@modify date 2025-11-22 18:27:25
@desc [description]
#endregion-->

# threadlocal

## 1. ThreadLocal 介绍

### 1.1. 官网介绍

从 Java 官方文档中的描述: ThreadLocal 类用来提供线程内部的局部变量。这种变量在多线程环境下访问（通过 get/set 方法访问）时能保证各个线程的变量相对独立于其它线程内的变量。ThreadLocal 实例通常来说都是 private static 类型的，用于关联线程和线程上下文。

我们可以得知 ThreadLocal 的作用是: 提供线程内的局部变量，不同的线程之间不会互相干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。

总结:

1. 线程并发
   * 在多线程并发的场景下
2. 传递数据
   * 通过 ThreadLocal 在同一线程、不同组件中传递公共变量
3. 线程隔离
   * 每个线程的变量都是独立的，不会互相影响

### 1.2. 基本使用

#### 1.2.1. 常用方法

| 方法声明 | 描述 |
| - | - |
| ThreadLocal() | 创建 ThreadLocal 对象 |
| public void set(T value) | 设置 当前线程绑定的局部变量 |
| public T get() | 获取 当前线程绑定的局部变量 |
| public void remove() | 移除 当前线程绑定的局部变量 |

#### 1.2.2. 使用案例

多线程 读写共享变量 出问题:

```java
public class MyDemo01 {
    private String content;

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public static void main(String[] args) {
        MyDemo01 instance = new MyDemo01();

        for (int i = 0; i < 5; i++) {
            Thread thread = new Thread(() -> {
                String currentThreadName = Thread.currentThread().getName();

                // 给 content 属性设置值
                instance.setContent(currentThreadName + "的数据");

                // 打印 content 属性的值
                System.out.println(currentThreadName + " => " + instance.getContent());
            });

            thread.setName("线程" + i);
            thread.start();
        }

        /* =>
        线程3 => 线程3的数据
        线程0 => 线程1的数据
        线程4 => 线程1的数据
        线程2 => 线程1的数据
        线程1 => 线程1的数据
         */
    }
}
```

使用 ThreadLocal 解决上述问题:

```java
public class MyDemo02 {
    private final ThreadLocal<String> threadLocal = new ThreadLocal<>();

    public String getContent() {
        return threadLocal.get();
    }

    public void setContent(String content) {
        threadLocal.set(content);
    }

    public static void main(String[] args) {
        MyDemo02 instance = new MyDemo02();

        for (int i = 0; i < 5; i++) {
            Thread thread = new Thread(() -> {
                String currentThreadName = Thread.currentThread().getName();

                // 给 content 属性设置值
                instance.setContent(currentThreadName + "的数据");

                // 打印 content 属性的值
                System.out.println(currentThreadName + " => " + instance.getContent());
            });

            thread.setName("线程" + i);
            thread.start();
        }
    }
}
```


### 1.3. ThreadLocal 类 与 synchronized 关键字

虽然 ThreadLocal 与 synchronized 关键字都能处理多线程并发访问变量的问题，不过两者处理问题的角度和思路不同

| - | synchronized | ThreadLocal |
| - | - | - |
| 原理 | 同步机制采用“以时间换空间”的方式，只提供了一份变量，让不同的线程排队访问 | ThreadLocal 采用“以空间换时间”的方式，为每一个线程都提供了一份变量的副本，从而实现同时访问而互不干扰 |
| 侧重点 | 多个线程之间访问资源的同步 | 多线程中让每个线程之间的数据相互隔离 |

## 2. 应用场景

转账案例：

* 涉及 service 、dao 层的方法，都要获取数据库连接来读写数据
* 可以将 Connection 对象保存在 ThreadLocal

优势：

* 传递数据
   * 保存每个线程绑定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题
* 线程隔离
   * 各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失